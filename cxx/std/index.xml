<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ Standard Library on Infinity Architect</title><link>https://cesun.info/cxx/std/</link><description>Recent content in C++ Standard Library on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 09 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/cxx/std/index.xml" rel="self" type="application/rss+xml"/><item><title>STLv2</title><link>https://cesun.info/cxx/std/stlv2/</link><pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/stlv2/</guid><description>infrastructures Core concept ranges::range T satisfies range if ranges:begin(t) and ranges::end(t) compiles, where t is lvalue expression of type T.
e.g. Both vector&amp;lt;int&amp;gt; and vector&amp;lt;int&amp;gt;&amp;amp; satisfies range.
Core concept ranges::view Every view is range.
view captures a non-reference type T that satisfies range, plus its copy ctor (if exist), copy= (if exist), move ctor (must exist), move= (must exist) all work in O(1). e.g. std::string_view satisfies view, but std::string_view &amp;amp; does not.</description></item><item><title>Smart Pointers</title><link>https://cesun.info/cxx/std/smart-pointers/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/smart-pointers/</guid><description>When not to use smart pointer Guideline:
raw pointer with new expression is always bad. there are situation in modern C++ where raw pointers make perfect sense. when destruction of resources is potentially-throwing Exception can&amp;rsquo;t be thrown from deleter. Use classic RAII class with noexcept(false) public API and noexcept(true) dtor instead of smart pointer.
https://stackoverflow.com/questions/130117/if-you-shouldnt-throw-exceptions-in-a-destructor-how-do-you-handle-errors-in-i
RAII class should be kept simple: never own 2 resources in 1 class.
Microsoft guide mentioned this (TODO: Bad things happends when RAII class wraps 2 resources?</description></item><item><title>C++ Randomness Infrastructure</title><link>https://cesun.info/cxx/std/random/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/random/</guid><description>Support for randomness was introduced since C++11. Its design revolves around the following types of templates / classes / concepts:
Concept std::uniform_random_bit_generator Concept std::uniform_random_bit_generator models (class of) URBG (uniform random bit generators).
An URBG is a functor
whose operator() returns a sequence of uniformly random bits in the form of an unsigned integral value. (i.e. the returned integer is also uniform within min() and max()) whose class has min() and max() static member functions and they make sense.</description></item><item><title>C++ STL Container &amp; Iterator</title><link>https://cesun.info/cxx/std/container/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/container/</guid><description>C++ specification leaves the implementation of STL iterators to be vendor-defined.
1template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt; 2class vector { 3 using iterator = implementation-defined ; 4 using const_iterator = implementation-defined ; 5} copy vector over list https://stackoverflow.com/questions/2209224/vector-vs-list-in-stl#comment20988862_2209233 https://www.stroustrup.com/bs_faq.html#list
Bjarne Strostrup actually made a test where he generated random numbers and then added them to a list and a vector respectively. The insertions were made so that the list/vector was ordered at all times.</description></item></channel></rss>