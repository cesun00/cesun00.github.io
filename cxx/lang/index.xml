<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ Language on Infinity Architect</title><link>https://cesun.info/cxx/lang/</link><description>Recent content in C++ Language on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 03 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/cxx/lang/index.xml" rel="self" type="application/rss+xml"/><item><title>The `=delete` and `=default` Function Definition</title><link>https://cesun.info/cxx/lang/delete-default-func/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/delete-default-func/</guid><description>&lt;p>This article discussed the &lt;code>= default&lt;/code> and the &lt;code>= delete&lt;/code> syntax, both of which serve as a function definition, not declaration.&lt;/p></description></item><item><title>Spell That Declaration Correctly!</title><link>https://cesun.info/cxx/lang/cdecl/</link><pubDate>Fri, 22 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/cdecl/</guid><description>Don&amp;rsquo;t mix pointers and non-pointers in the same declaration 1// do 2int *ptr_a, *ptr_b; 3int c; 4 5// don&amp;#39;t 6int* ptr_a, b; copy pointer to const vs. const pointer 1const int *ptr_a;	// pointer to const 2int *const ptr_b;	// const pointer; Recommended: asterisk preceeds const immediately copy a pointer to array vs. array of pointers 1int (*ptr_to_arr)[42]; // Pointer to an array 2int *ptr_arr[42]; // Array of pointers. copy 2d Array on Heap 1/** 2 * @brief 2D array malloc with compilation-time known size.</description></item><item><title>GNU CPP: the C/C++ Preprocessor</title><link>https://cesun.info/cxx/lang/preprocessor/</link><pubDate>Sat, 25 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/preprocessor/</guid><description>&lt;p>GCC C/C++ shares the same preprocessor program &lt;code>cpp&lt;/code>. Several of its primary functionalities are discussed.&lt;/p></description></item><item><title>C++ Initialization Types</title><link>https://cesun.info/cxx/lang/init/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/init/</guid><description>&lt;p>Initialization in C++ happens&lt;/p>
&lt;ol>
&lt;li>as an optional part of a variable declaration that gives it an initial value.&lt;/li>
&lt;li>when an expression as a function argument is bound to a function parameter&lt;/li>
&lt;li>when an expression after function &lt;code>return&lt;/code> is bound to the returned entity (received by caller or not)&lt;/li>
&lt;/ol>
&lt;p>The latter 2 can be equivalently viewed as a variable declaration with &lt;code>initializer&lt;/code> in an obvious way.
We&amp;rsquo;ll be focusing on the first scenario, which is the only hard part.&lt;/p>
&lt;p>This article discusses various initialization syntax and their behavior in terms of C++ specification.
A comparison with C is given.&lt;/p></description></item><item><title>Memorandum on C++ Specification</title><link>https://cesun.info/cxx/lang/spec/</link><pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/spec/</guid><description>Named Requirements Pre-C++20 versions lack the syntatic expressiveness to put explicit restriction on type template argument. A template parameter takes whatever arguments provided, and the compiler doesn&amp;rsquo;t complain until the instantiation makes an ill-formed program (including static_assert failure), i.e. compile-time duck typing.
When standard text needs to describe certain contract on template arguments with user programmer, the word named requirement is coined to refer to such contract. Examples are
std::find_if can be instantiated with whatever (deduced) type argument, but you get an ill-formed instantiation unless the first and second argument Since C++20,</description></item><item><title>Overview: The Class Construct</title><link>https://cesun.info/cxx/lang/class/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/class/</guid><description>constructor Within a class member specification, the declaration of a non-static, non-template member function is a constructor declaration if
1struct S { 2 S(); // declares the constructor 3}; 4 5S::S() { } // defines the constructor copy The constructor is considered a function with no name.
Special Member Functions (SMF) (c++20 11.4.3.1) A class have
at most 1 default constructor, at most 1 copy constructor, at most 1 move constructor, at most 1 copy assignment operator, at most 1 move assignment operator, and prospective destructors all of which are known as special member functions of that class.</description></item><item><title>Value Category and Move Semantics</title><link>https://cesun.info/cxx/lang/move/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/move/</guid><description>Value category is a property of an expression. Prior to C++11, the specification only identifies 2 value categories:
lvalue: roughly means expressions that can appear on the left-hand side of assignment operator =
rvalue: roughly means expressions that cannot
As a special case, all function calls in C are rvalue, thus puts(&amp;quot;foo&amp;quot;) = 42 is illegal. But the introduction of reference in C++ breaks the game, foo() = 42 is valid if foo returns a non-const reference.</description></item><item><title>Static Initialization Fiasco</title><link>https://cesun.info/cxx/lang/static-init/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/static-init/</guid><description>Static Initialization TLDR: don&amp;rsquo;t use non-pointer static variables at all.
Within a single translation unit, static variables are guaranteed to be initialized from top to bottom. You can let the initializer of a static variable depend on a previous one, in a single translation unit:
1static int foo = 42; // live in .data 2static int bar; // live in .bss 3static int zoo = foo + bar + 42; // live in .</description></item><item><title>Variadic Arguments in C/C++</title><link>https://cesun.info/cxx/lang/variadic/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/variadic/</guid><description>Variadic Macro Functions Preprocessors of gcc and clang supports variadic macro function. This feature is mandatory since C99 / C++11.
1// An ellipsis as the last macro parameter becomes the sink. 2// Use `__VA_ARGS__` to refer to whatever token sequence the sink accepts. 3#define foo(...) real_foo(42, __VA_ARGS__) 4 5// GNUCPP-specific named sink: 6#define foo(bar...) real_foo(42, bar) 7 8// Preceding normal arguments are allowed, with some problems 9#define eprintf(format, ...) std::fprintf(stderr, format, __VA_ARGS__) 10 11eprintf(&amp;#34;hooray!</description></item><item><title>Exception Infrastructure in C++</title><link>https://cesun.info/cxx/lang/exception/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/exception/</guid><description>C++ allows an instance of arbitrary type to be thrown as exception. But always only throw liskov-able subclass of std::exception.
Throw by value, catch by reference (preferably to-const).
1try { 2 // ... somewhere potentially deep down the calling stack 3 throw std::DerivedException{}; 4} catch(const std::BaseException &amp;amp;e) { 5 // handle polymorphic e 6} copy catch(...) is the syntax to catches everything, and caught object can&amp;rsquo;t be referred. This should be seldom useful if (2) is followed.</description></item><item><title>Copy / Move Elision and Return Value Optimization (RVO)</title><link>https://cesun.info/cxx/lang/copy-elision-and-rvo/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/copy-elision-and-rvo/</guid><description>Copy / Move Elision During a function call, copies may occur multiple times for arguemnts and function return:
1class X { 2public: 3 X(): id{&amp;#34;unknown&amp;#34;} {std::puts(&amp;#34;default ctor&amp;#34;);} 4 X(const std::string id): id{id} {std::puts(&amp;#34;ctor with given id&amp;#34;);} 5 X(const X &amp;amp;other): id{other.id} {std::puts(&amp;#34;copy ctor&amp;#34;);} 6 X(X &amp;amp;&amp;amp;other): id{std::move(other.id)} {std::puts(&amp;#34;move ctor&amp;#34;);} 7 ~X(){std::puts(&amp;#34;dtor&amp;#34;);} 8private: 9 std::string id; 10}; 11 12void foo(X gg) { } 13 14X bar() { 15 std::string id{/* e.g. get id from RPC connection */}; 16 return X{id}; 17} 18 19X zoo() { 20 X named{&amp;#34;zoo - named&amp;#34;}; 21 return named; 22} 23 24int main() { 25 X gg = zoo(); 26} copy [, c++17) gcc stop eliding copy / move ctors when -std=c++14 -fno-elide-constructors.</description></item><item><title>C++ Idioms Collections</title><link>https://cesun.info/cxx/lang/idioms/</link><pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/idioms/</guid><description>&lt;p>Some C++ Idioms collected. Use this article as a cheetsheet.&lt;/p></description></item><item><title>Inline Static Function</title><link>https://cesun.info/cxx/lang/inline-static-function/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/inline-static-function/</guid><description>&lt;p>In 95% of the scenarios, using &lt;code>inline static&lt;/code> function with implementation in a header file is what you should do when you want to inline calls to a function; (there is no function anymore, just a code snippet copied and pasted)&lt;/p>
&lt;p>The situation gets a little bit complicated if you want or have to separate the declaration and definition of a function,
or want to know how and why of this practice.&lt;/p></description></item></channel></rss>