<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ Template on Infinity Architect</title><link>https://cesun.info/cxx/lang/template/</link><description>Recent content in C++ Template on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 12 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/cxx/lang/template/index.xml" rel="self" type="application/rss+xml"/><item><title>SFINAE, aghhhh</title><link>https://cesun.info/cxx/lang/template/sfinae/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/sfinae/</guid><description>&lt;h2 id="plain-function-overloads-in-a-world-without-template">plain function overloads in a world without template&lt;/h2>
&lt;p>In a world without template, When a function call expression (as described in&lt;code>[expr.call]&lt;/code>) is encountered,
compiler performs 2 steps to eventually determine which function to call.&lt;/p></description></item><item><title>Member templates</title><link>https://cesun.info/cxx/lang/template/member-template/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/member-template/</guid><description>A member template is a function / class / variable / alias template that appears inside the member-specification of the class (i.e. class body).
All instantiations of member templates have equal member access as their non-template counterparts. The static semantics applies normally. Member templates are different creatures than other members, in that their code is compiled at client side (or for metaprogramming code, evaluated at client&amp;rsquo;s compiler).
Class members are fixed once library author released the binaries and headers.</description></item><item><title>Overview of C++ Template</title><link>https://cesun.info/cxx/lang/template/overview/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/overview/</guid><description>&lt;p>Essentially, the template system in C++ is an advanced macro processor.
Arbitrary textual program sources can be generated via the instantiation of a template.
Depending on the role of the generated construct, there are&lt;/p></description></item><item><title>C++ Metaprogramming</title><link>https://cesun.info/cxx/lang/template/meta-programming/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/meta-programming/</guid><description>Metaprogramming in C++ refer to the exercise of writting bool constexpr evaluated by the client compiler, such that correct template instantiation is eventually instantiated.
check if T is not const or volatile 1std::same_as&amp;lt;T, std::remove_cv_t&amp;lt;T&amp;gt;&amp;gt; copy Use std::addressof to take address of object Work against overloaded operator&amp;amp;.
Use std::to_address to get the address value of (smart / raw) pointers 1#include &amp;lt;type_traits&amp;gt; 2#include &amp;lt;memory&amp;gt; 3#include &amp;lt;cstdio&amp;gt; 4 5int main () { 6 // std::toaddress 7 // 1) work for both smart and raw pointer 8 auto int_up = std::make_unique&amp;lt;int&amp;gt;(42); 9 int *int_p = new int{22}; 10 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(int_up)); 11 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(int_p)); 12 13 // 2) avoid the trap of std::addressof(*ptr) 14 int *wild_int_p = int_p + 10000000; // pointer arithmetic is well-defined behavior 15 //std::printf(&amp;#34;%p\n&amp;#34;, std::addressof(*wild_int_p)); // undefined behavior 16 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(wild_int_p)); // ok 17 18 delete int_p; 19} copy https://stackoverflow.</description></item><item><title>Introduction to C++20 Concept</title><link>https://cesun.info/cxx/lang/template/concept/</link><pubDate>Sun, 27 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/concept/</guid><description>Prior to C++20, type parameters in a template definition are introduced with template&amp;lt;typename T&amp;gt; ..., where T can bind to any existing type as long as the resulting code compiles. There is no way for a client programmer, upon seeing the template definition in a header file, to know what types can be used as arguments to the template other than reading the document.
Concepts is a C++20 feature that restricts, at the language level, the set of types that can be used as a type argument to a template.</description></item><item><title>Function Template</title><link>https://cesun.info/cxx/lang/template/function-template/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/function-template/</guid><description>Canonically, a function template &amp;hellip;
&amp;hellip; is declared by 1template&amp;lt;typename T&amp;gt; 2void foo(T); copy C++20 allows a function declaration to have placeholder type (i.e. auto) or constrained placeholder type (i.e. constrained auto) as an equivalent syntax of function template declaration with type parameter:
1// equivalent to above 2void foo(auto); copy &amp;hellip; is defined by 1template&amp;lt;typename T&amp;gt; 2void foo(T) {/**/} copy In most cases, the definition part of a function template is trivial, and doesn&amp;rsquo;t affect the templating resolution or metaprogramming magic at all.</description></item><item><title>Template Specialization</title><link>https://cesun.info/cxx/lang/template/specialization/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/specialization/</guid><description>Specialization allows a complete different template definition to be used when specific 1) template arguments, or 2) patterns of template arguments is provided.
is the case for both full and partial specialization is more expressive, and is only the case for partial specialization. Specialization embodies ad-hoc polymorphism of metaprogramming: the same template name (interface) works for different type by really having multiple templates definition. It resembles function overloads, and is the the metaprogramming counterpart of the latter in many ways.</description></item><item><title>Template Parameters</title><link>https://cesun.info/cxx/lang/template/template-parameter/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/template-parameter/</guid><description>This article documents C++ features related to parameterized templates, common for all of function / class / whatever templates.
Template Parameters A template declares its parameters list in a pair of angle brackets. There are 3 types of template parameters:
type template parameter receives a type identifier as argument
It&amp;rsquo;s led by a typename or a class keyword:
1template&amp;lt;typename T&amp;gt; 2class Container&amp;lt;T&amp;gt; {} copy type template parameter can be constrained, in which case it&amp;rsquo;s led by concept name:</description></item><item><title>Class Template</title><link>https://cesun.info/cxx/lang/template/class-template/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/class-template/</guid><description>Class Template Argument Deduction (CTAD) (c++17) TODO: CTAD happends through FTAD on class&amp;rsquo;s ctor?
misc Mind static data member in class template All instantiations of a class template with the same template arguments share the same memory of data member:
1#include &amp;lt;cstdio&amp;gt; 2 3template&amp;lt;int N&amp;gt; 4struct Foo { 5 static int data[N]; 6}; 7 8template&amp;lt;int N&amp;gt; int &amp;lt;MAXN&amp;gt;::data[N]; 9 10int main() { 11 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 12 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 13 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 14 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 15} copy</description></item></channel></rss>