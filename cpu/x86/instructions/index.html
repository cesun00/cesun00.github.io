<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>x86 Base / Extended Instructions Review | Infinity Architect</title>
<link rel=stylesheet href=/main.css><script type=importmap>
  {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.167.1/+esm"
      }
  }
  </script><script type=module src=/theme.mjs></script><style>.tag-android{background-color:hsl(0deg 80% 70%)}.dark .tag-android{background-color:hsl(0deg 80% 20%)}.tag-annotation{background-color:hsl(50deg 80% 70%)}.dark .tag-annotation{background-color:hsl(50deg 80% 20%)}.tag-assembly{background-color:hsl(100deg 80% 70%)}.dark .tag-assembly{background-color:hsl(100deg 80% 20%)}.tag-asymmetrical-cryptography{background-color:hsl(150deg 80% 70%)}.dark .tag-asymmetrical-cryptography{background-color:hsl(150deg 80% 20%)}.tag-awk{background-color:hsl(200deg 80% 70%)}.dark .tag-awk{background-color:hsl(200deg 80% 20%)}.tag-bootloader{background-color:hsl(250deg 80% 70%)}.dark .tag-bootloader{background-color:hsl(250deg 80% 20%)}.tag-bytecode{background-color:hsl(300deg 80% 70%)}.dark .tag-bytecode{background-color:hsl(300deg 80% 20%)}.tag-c{background-color:hsl(350deg 80% 70%)}.dark .tag-c{background-color:hsl(350deg 80% 20%)}.tag-cxx{background-color:hsl(40deg 80% 70%)}.dark .tag-cxx{background-color:hsl(40deg 80% 20%)}.tag-cxx-stl{background-color:hsl(90deg 80% 70%)}.dark .tag-cxx-stl{background-color:hsl(90deg 80% 20%)}.tag-cgroup{background-color:hsl(140deg 80% 70%)}.dark .tag-cgroup{background-color:hsl(140deg 80% 20%)}.tag-cheetsheet{background-color:hsl(190deg 80% 70%)}.dark .tag-cheetsheet{background-color:hsl(190deg 80% 20%)}.tag-clang{background-color:hsl(240deg 80% 70%)}.dark .tag-clang{background-color:hsl(240deg 80% 20%)}.tag-coding-theory{background-color:hsl(290deg 80% 70%)}.dark .tag-coding-theory{background-color:hsl(290deg 80% 20%)}.tag-compression{background-color:hsl(340deg 80% 70%)}.dark .tag-compression{background-color:hsl(340deg 80% 20%)}.tag-concept{background-color:hsl(30deg 80% 70%)}.dark .tag-concept{background-color:hsl(30deg 80% 20%)}.tag-cpu{background-color:hsl(80deg 80% 70%)}.dark .tag-cpu{background-color:hsl(80deg 80% 20%)}.tag-crawler{background-color:hsl(130deg 80% 70%)}.dark .tag-crawler{background-color:hsl(130deg 80% 20%)}.tag-cryptography{background-color:hsl(180deg 80% 70%)}.dark .tag-cryptography{background-color:hsl(180deg 80% 20%)}.tag-css{background-color:hsl(230deg 80% 70%)}.dark .tag-css{background-color:hsl(230deg 80% 20%)}.tag-database{background-color:hsl(280deg 80% 70%)}.dark .tag-database{background-color:hsl(280deg 80% 20%)}.tag-deflate{background-color:hsl(330deg 80% 70%)}.dark .tag-deflate{background-color:hsl(330deg 80% 20%)}.tag-design{background-color:hsl(20deg 80% 70%)}.dark .tag-design{background-color:hsl(20deg 80% 20%)}.tag-dns{background-color:hsl(70deg 80% 70%)}.dark .tag-dns{background-color:hsl(70deg 80% 20%)}.tag-dom{background-color:hsl(120deg 80% 70%)}.dark .tag-dom{background-color:hsl(120deg 80% 20%)}.tag-driver{background-color:hsl(170deg 80% 70%)}.dark .tag-driver{background-color:hsl(170deg 80% 20%)}.tag-elastic{background-color:hsl(220deg 80% 70%)}.dark .tag-elastic{background-color:hsl(220deg 80% 20%)}.tag-elf{background-color:hsl(270deg 80% 70%)}.dark .tag-elf{background-color:hsl(270deg 80% 20%)}.tag-elk{background-color:hsl(320deg 80% 70%)}.dark .tag-elk{background-color:hsl(320deg 80% 20%)}.tag-flex{background-color:hsl(10deg 80% 70%)}.dark .tag-flex{background-color:hsl(10deg 80% 20%)}.tag-gc{background-color:hsl(60deg 80% 70%)}.dark .tag-gc{background-color:hsl(60deg 80% 20%)}.tag-gcc{background-color:hsl(110deg 80% 70%)}.dark .tag-gcc{background-color:hsl(110deg 80% 20%)}.tag-gnu{background-color:hsl(160deg 80% 70%)}.dark .tag-gnu{background-color:hsl(160deg 80% 20%)}.tag-go{background-color:hsl(210deg 80% 70%)}.dark .tag-go{background-color:hsl(210deg 80% 20%)}.tag-gzip{background-color:hsl(260deg 80% 70%)}.dark .tag-gzip{background-color:hsl(260deg 80% 20%)}.tag-hash{background-color:hsl(310deg 80% 70%)}.dark .tag-hash{background-color:hsl(310deg 80% 20%)}.tag-http{background-color:hsl(0deg 80% 70%)}.dark .tag-http{background-color:hsl(0deg 80% 20%)}.tag-huffman{background-color:hsl(50deg 80% 70%)}.dark .tag-huffman{background-color:hsl(50deg 80% 20%)}.tag-java{background-color:hsl(100deg 80% 70%)}.dark .tag-java{background-color:hsl(100deg 80% 20%)}.tag-java-module{background-color:hsl(150deg 80% 70%)}.dark .tag-java-module{background-color:hsl(150deg 80% 20%)}.tag-javascript{background-color:hsl(200deg 80% 70%)}.dark .tag-javascript{background-color:hsl(200deg 80% 20%)}.tag-jdk{background-color:hsl(250deg 80% 70%)}.dark .tag-jdk{background-color:hsl(250deg 80% 20%)}.tag-js{background-color:hsl(300deg 80% 70%)}.dark .tag-js{background-color:hsl(300deg 80% 20%)}.tag-jvm{background-color:hsl(350deg 80% 70%)}.dark .tag-jvm{background-color:hsl(350deg 80% 20%)}.tag-kernel{background-color:hsl(40deg 80% 70%)}.dark .tag-kernel{background-color:hsl(40deg 80% 20%)}.tag-lexer{background-color:hsl(90deg 80% 70%)}.dark .tag-lexer{background-color:hsl(90deg 80% 20%)}.tag-linux{background-color:hsl(140deg 80% 70%)}.dark .tag-linux{background-color:hsl(140deg 80% 20%)}.tag-log4j2{background-color:hsl(190deg 80% 70%)}.dark .tag-log4j2{background-color:hsl(190deg 80% 20%)}.tag-lz77{background-color:hsl(240deg 80% 70%)}.dark .tag-lz77{background-color:hsl(240deg 80% 20%)}.tag-make{background-color:hsl(290deg 80% 70%)}.dark .tag-make{background-color:hsl(290deg 80% 20%)}.tag-makefile{background-color:hsl(340deg 80% 70%)}.dark .tag-makefile{background-color:hsl(340deg 80% 20%)}.tag-maven{background-color:hsl(30deg 80% 70%)}.dark .tag-maven{background-color:hsl(30deg 80% 20%)}.tag-memory{background-color:hsl(80deg 80% 70%)}.dark .tag-memory{background-color:hsl(80deg 80% 20%)}.tag-multithreading{background-color:hsl(130deg 80% 70%)}.dark .tag-multithreading{background-color:hsl(130deg 80% 20%)}.tag-mybatis{background-color:hsl(180deg 80% 70%)}.dark .tag-mybatis{background-color:hsl(180deg 80% 20%)}.tag-mysql{background-color:hsl(230deg 80% 70%)}.dark .tag-mysql{background-color:hsl(230deg 80% 20%)}.tag-nasm{background-color:hsl(280deg 80% 70%)}.dark .tag-nasm{background-color:hsl(280deg 80% 20%)}.tag-node{background-color:hsl(330deg 80% 70%)}.dark .tag-node{background-color:hsl(330deg 80% 20%)}.tag-nodejs{background-color:hsl(20deg 80% 70%)}.dark .tag-nodejs{background-color:hsl(20deg 80% 20%)}.tag-openssl{background-color:hsl(70deg 80% 70%)}.dark .tag-openssl{background-color:hsl(70deg 80% 20%)}.tag-playwright{background-color:hsl(120deg 80% 70%)}.dark .tag-playwright{background-color:hsl(120deg 80% 20%)}.tag-posix{background-color:hsl(170deg 80% 70%)}.dark .tag-posix{background-color:hsl(170deg 80% 20%)}.tag-powershell{background-color:hsl(220deg 80% 70%)}.dark .tag-powershell{background-color:hsl(220deg 80% 20%)}.tag-programming-langauge{background-color:hsl(270deg 80% 70%)}.dark .tag-programming-langauge{background-color:hsl(270deg 80% 20%)}.tag-programming-language{background-color:hsl(320deg 80% 70%)}.dark .tag-programming-language{background-color:hsl(320deg 80% 20%)}.tag-qemu{background-color:hsl(10deg 80% 70%)}.dark .tag-qemu{background-color:hsl(10deg 80% 20%)}.tag-redis{background-color:hsl(60deg 80% 70%)}.dark .tag-redis{background-color:hsl(60deg 80% 20%)}.tag-retrocomputing{background-color:hsl(110deg 80% 70%)}.dark .tag-retrocomputing{background-color:hsl(110deg 80% 20%)}.tag-rfc{background-color:hsl(160deg 80% 70%)}.dark .tag-rfc{background-color:hsl(160deg 80% 20%)}.tag-sdram{background-color:hsl(210deg 80% 70%)}.dark .tag-sdram{background-color:hsl(210deg 80% 20%)}.tag-sed{background-color:hsl(260deg 80% 70%)}.dark .tag-sed{background-color:hsl(260deg 80% 20%)}.tag-slf4j{background-color:hsl(310deg 80% 70%)}.dark .tag-slf4j{background-color:hsl(310deg 80% 20%)}.tag-spring{background-color:hsl(0deg 80% 70%)}.dark .tag-spring{background-color:hsl(0deg 80% 20%)}.tag-spring-boot{background-color:hsl(50deg 80% 70%)}.dark .tag-spring-boot{background-color:hsl(50deg 80% 20%)}.tag-spring-data{background-color:hsl(100deg 80% 70%)}.dark .tag-spring-data{background-color:hsl(100deg 80% 20%)}.tag-spring-ioc{background-color:hsl(150deg 80% 70%)}.dark .tag-spring-ioc{background-color:hsl(150deg 80% 20%)}.tag-sql{background-color:hsl(200deg 80% 70%)}.dark .tag-sql{background-color:hsl(200deg 80% 20%)}.tag-streaming{background-color:hsl(250deg 80% 70%)}.dark .tag-streaming{background-color:hsl(250deg 80% 20%)}.tag-template{background-color:hsl(300deg 80% 70%)}.dark .tag-template{background-color:hsl(300deg 80% 20%)}.tag-testing{background-color:hsl(350deg 80% 70%)}.dark .tag-testing{background-color:hsl(350deg 80% 20%)}.tag-thymeleaf{background-color:hsl(40deg 80% 70%)}.dark .tag-thymeleaf{background-color:hsl(40deg 80% 20%)}.tag-tls{background-color:hsl(90deg 80% 70%)}.dark .tag-tls{background-color:hsl(90deg 80% 20%)}.tag-tomcat{background-color:hsl(140deg 80% 70%)}.dark .tag-tomcat{background-color:hsl(140deg 80% 20%)}.tag-transaction{background-color:hsl(190deg 80% 70%)}.dark .tag-transaction{background-color:hsl(190deg 80% 20%)}.tag-transistor{background-color:hsl(240deg 80% 70%)}.dark .tag-transistor{background-color:hsl(240deg 80% 20%)}.tag-ts{background-color:hsl(290deg 80% 70%)}.dark .tag-ts{background-color:hsl(290deg 80% 20%)}.tag-typescript{background-color:hsl(340deg 80% 70%)}.dark .tag-typescript{background-color:hsl(340deg 80% 20%)}.tag-unix{background-color:hsl(30deg 80% 70%)}.dark .tag-unix{background-color:hsl(30deg 80% 20%)}.tag-web{background-color:hsl(80deg 80% 70%)}.dark .tag-web{background-color:hsl(80deg 80% 20%)}.tag-x86{background-color:hsl(130deg 80% 70%)}.dark .tag-x86{background-color:hsl(130deg 80% 20%)}.tag-x86_64{background-color:hsl(180deg 80% 70%)}.dark .tag-x86_64{background-color:hsl(180deg 80% 20%)}.tag-x86-64{background-color:hsl(230deg 80% 70%)}.dark .tag-x86-64{background-color:hsl(230deg 80% 20%)}.tag-xpath{background-color:hsl(280deg 80% 70%)}.dark .tag-xpath{background-color:hsl(280deg 80% 20%)}.tag-zlib{background-color:hsl(330deg 80% 70%)}.dark .tag-zlib{background-color:hsl(330deg 80% 20%)}</style></head><body><script>localStorage.getItem("dark-theme")&&document.body.classList.add("dark")</script><header><h2 id=banner><a href=/>Infinity Architect</a></h2><div id=top-sections><a href=/android/ class=hoverable>Android </a><a href=/cxx/ class=hoverable>C/C++ </a><a href=/compression/ class=hoverable>Compression </a><a href=/cpu/ class=active>CPU </a><a href=/crypto/ class=hoverable>Cryptography </a><a href=/db/ class=hoverable>Database </a><a href=/ee/ class=hoverable>Electronic Engineering </a><a href=/linux/ class=hoverable>GNU/Linux </a><a href=/go/ class=hoverable>Golang </a><a href=/java/ class=hoverable>Java </a><a href=/microservice/ class=hoverable>Microservice </a><a href=/net/ class=hoverable>Network & Protocol </a><a href=/physics/ class=hoverable>Physics </a><a href=/retro/ class=hoverable>Retro-Computing </a><a href=/toy/ class=hoverable>Toys </a><a href=/windev/ class=hoverable>Window</a></div><div class=theme-switch style="align-self:center;margin:auto 20px"><input type=checkbox id=theme-checkbox>
<label for=theme-checkbox><div></div><span><svg viewBox="0 0 24 24" fill="currentcolor" class="w-6 h-6"><path fill-rule="evenodd" d="M9.528 1.718a.75.75.0 01.162.819A8.97 8.97.0 009 6a9 9 0 009 9 8.97 8.97.0 003.463-.69.75.75.0 01.981.98 10.503 10.503.0 01-9.694 6.46c-5.799.0-10.5-4.701-10.5-10.5.0-4.368 2.667-8.112 6.46-9.694a.75.75.0 01.818.162z" clip-rule="evenodd"/></svg>
</span><span><svg viewBox="0 0 24 24" fill="currentcolor" class="w-6 h-6"><path d="M12 2.25a.75.75.0 01.75.75v2.25a.75.75.0 01-1.5.0V3a.75.75.0 01.75-.75zM7.5 12a4.5 4.5.0 119 0 4.5 4.5.0 01-9 0zM18.894 6.166a.75.75.0 00-1.06-1.06l-1.591 1.59a.75.75.0 101.06 1.061l1.591-1.59zM21.75 12a.75.75.0 01-.75.75h-2.25a.75.75.0 010-1.5H21a.75.75.0 01.75.75zm-3.916 6.894a.75.75.0 001.06-1.06l-1.59-1.591a.75.75.0 10-1.061 1.06l1.59 1.591zM12 18a.75.75.0 01.75.75V21a.75.75.0 01-1.5.0v-2.25A.75.75.0 0112 18zM7.758 17.303a.75.75.0 00-1.061-1.06l-1.591 1.59a.75.75.0 001.06 1.061l1.591-1.59zM6 12a.75.75.0 01-.75.75H3a.75.75.0 010-1.5h2.25A.75.75.0 016 12zm.697-4.243a.75.75.0 001.06-1.06l-1.59-1.591a.75.75.0 00-1.061 1.06l1.59 1.591z"/></svg></span></label></div></header><main><article class=basic-text><div style=font-family:monospace;font-size:1.5em><div class=basic-text>/<a href=/>HOME</a>/<a href=/cpu/>CPU</a>/<a href=/cpu/x86/>x86 Architecture</a>/
$</div></div><div style=margin-bottom:60px><h1 style=margin-bottom:0>x86 Base / Extended Instructions Review</h1><p class=aux-text style=margin-top:0>Published at: July 5, 2023
| Last modification: June 20, 2024</p><div style=line-height:2em><span class="page-tag tag-cpu">CPU</span>
<span class="page-tag tag-x86">x86</span></div></div><div><p>A quick review of x86 base instructions and extensions.</p><h3 id=general-purpose-data-movement>General Purpose Data Movement:</h3><ol><li><p><code>MOV</code>: transfers a byte, word, or doubleword from the source operand to the destination operand.</p><p>See also <code>MOVSX</code> and <code>MOVZX</code></p></li><li><p><code>XCHG</code> (Exchange): swaps the contents of two operands. When used with a memory operand, XCHG automatically activates the LOCK signal.</p></li></ol><h3 id=stack-manipulation>Stack Manipulation:</h3><ol><li><code>PUSH</code> / <code>PUSHA</code></li><li><code>POP</code> / <code>POPA</code></li></ol><h3 id=data-type-widening>Data Type Widening</h3><p>Sign extension of a narrow data type to a wider one;
(extra bits of the larger item with the value of the sign bit of the smaller item)</p><p>The <code>CXY</code> family has no operand and only read from <code>EAX</code> registers:</p><ol><li><code>CBW</code> (byte to word): <code>AL</code> -> <code>AX</code> (<code>AH</code> <code>AL</code>)</li><li><code>CWD</code> (word to doubleword): <code>AX</code> -> <code>DX</code> <code>AX</code></li><li><code>CWDE</code> (Word to Doubleword Extended): <code>AX</code> -> <code>EAX</code></li><li><code>CDQ</code> (doubleword to quad-word): <code>EAX</code> -> <code>EDX</code> <code>EAX</code></li></ol><p>The <code>MOV</code> variants take 2 operands, at most one can be memory access:</p><ol><li><code>MOVSX dest, src</code> (Move with Sign Extension): sign extend and move 8-bit src to 16-bit dest, or 16-bit src to 32-bit dest</li><li><code>MOVZX dest, src</code> (Move with Zero Extension): zero extend (i.e. inserting high-order zero regardlessly) and move 8-bit src to 16-bit dest, or 16-bit src to 32-bit dest.</li></ol><h3 id=integer-arithmetic--comparison>Integer Arithmetic & Comparison</h3><ol><li>overflow is defined as;</li><li>borrow is defined as;</li><li>all instructions in this section update all <code>OF, SF, ZF, AF, and PF</code> according to the result. See details for what happens to <code>CF</code>.</li></ol><ul><li><p><code>NEG dest</code>: <code>dest = 0 - dest</code>; set <code>CF</code> if <code>dest</code> is not 0, unset otherwise.</p></li><li><p><code>ADD dest,src</code>: <code>dest = dest + src</code>; set <code>CF</code> if overflow, unset otherwise.</p></li><li><p><code>ADC dest,src</code> (add with carry): <code>dest = dest + src + CF</code>; No flag affected.</p><p>Pattern: <code>ADD</code> followed multiple <code>ADC</code> instructions can be used to add numbers longer than 32 bits.</p></li><li><p><code>INC dest</code>: <code>dest = dest + 1</code>; <code>CF</code> unaffected.</p></li><li><p><code>SUB dest, src</code>: <code>dest = dest - src</code>; set <code>CF</code> if borrow, and update all of <code>OF, SF, ZF, AF, PF</code> accordingly</p></li><li><p><code>CMP dest, src</code>: like <code>SUB</code> but don&rsquo;t write back the result.</p></li><li><p><code>SBB dest, src</code> (subtract with borrow): <code>dest = dest - src - CF</code>;</p><p>Pattern: <code>SUB</code> followed by multiple <code>SBB</code> instructions may be used to subtract numbers longer than 32 bits.</p></li><li><p><code>DEC dest</code>: <code>dest = dest - 1</code>; <code>CF</code> unaffected.</p></li><li><p><code>MUL src</code> (Unsigned Integer Multiply): <code>AX = AL * src</code> or <code>DX:AX = AX * src</code> or <code>EDX:EAX = EAX * src</code>;</p></li><li><p><code>IMUL</code> (Signed Integer Multiply):</p><ul><li><code>IMUL dest</code>:</li><li><code>IMUL dest, src</code></li><li><code>IMUL dest, src1,src2,</code></li></ul></li><li><p>DIV</p></li><li><p>IDIV</p></li></ul><h3 id=decimal>Decimal</h3><p>x86 has some limited support for decimal arithmetic (let&rsquo;s reserve the word floating point to x87 coprocessor).
It is based on packed BCD representation:</p><p>All these instructions cause undefined behavior in AMD64 architecture:</p><ol><li><code>DAA</code></li><li><code>DAS</code></li><li><code>AAA</code></li><li><code>AAS</code></li><li><code>AAM</code></li><li><code>AAD</code></li></ol><p>See also AMD64 architecture instruction <code>fbld</code> and <code>fbstp</code> which don&rsquo;t exist in 80386.</p><h3 id=bit-manipulation>bit manipulation</h3><p>The following 4 instructions update <code>SF, ZF, and PF</code> flags according to the result, clears <code>OF</code> and <code>CF</code>, and leaves <code>AF</code> undefined.</p><ul><li><code>NOT dest</code>: flip each bit in <code>dest</code></li><li><code>AND dest, src</code>: bitwise AND and store result to <code>dest</code>; See <code>TEST</code> for a no-write-back version of AND.</li><li><code>OR dest, src</code>: bitwise OR and store result to <code>dest</code></li><li><code>XOR dest, src</code>: bitwise OR and store result to <code>dest</code></li></ul><p>AND, OR, and XOR clear OF and CF, leave AF undefined, and update SF, ZF, and PF.</p><p>The location of the bit is specified as an offset from the low-order end of the operand.</p><ul><li><p><code>BT src, offset</code> (Bit test): store the <code>offset</code>-indexed bit in <code>src</code> to <code>CF</code></p></li><li><p><code>BTS src, offset</code> (Bit test and set): same as <code>BT</code>, plus set that bit in <code>src</code> to 1</p></li><li><p><code>BTR src, offset</code> (Bit test and reset): same as <code>BT</code>, plus set that bit in <code>src</code> to 0</p></li><li><p><code>BTC src, offset</code> (Bit test and complement): same as <code>BT</code>, plus flip that bit in <code>src</code></p></li><li><p><code>BSF dest, src</code> (Bit Scan Forward): find the least significant 1 in <code>src</code> and store its bit index to <code>dest</code>.</p></li><li><p><code>BSR</code> (Bit Scan Reverse): find the most significant 1 in <code>src</code> and store its bit index to <code>dest</code></p></li></ul><p>(The bit index of the least significant bit is 0.)</p><div class=codeblock-hook><pre tabindex=0><code>&lt;-most significant (left)           least significant (right)-&gt;
31 30 29 28     ...                                       2 1 0</code></pre><button>copy</button></div><ul><li><code>SAL dest</code> / <code>SAL dest, count</code> (Shift Arithmetic Left): shift <code>dest</code> left by <code>1</code> or <code>count</code>, pad 0 from right.</li><li><code>SHL</code> (Shift Logical Left): identical to <code>SAL</code></li><li><code>SAR</code> (Shift Arithmetic Right):</li><li><code>SHR</code> (Shift Logical Right):</li><li><code>SHLD</code> (Shift Left Double)</li><li><code>SHRD</code> (Shift Right Double)</li></ul><p>Pattern: <code>SAR</code> can be used to simulate <code>IDIV</code>:</p><div class=codeblock-hook><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1</span><span><span style=color:#a6e22e>TODO</span></span></span></code></pre></div><button>copy</button></div><ul><li><code>ROL</code> (Rotate Left)</li><li><code>ROR</code> (Rotate Right)</li><li><code>RCL</code> (Rotate through carry left)</li><li><code>RCR</code> (Rotate through carry Right)</li></ul><h3 id=condition-and-branching-jump>Condition and Branching (Jump)</h3><p>Jump instructions can be more complicated than one imagine - due to the complexity introduced by the segmented memory model.</p><p>The target of a jump is always another instruction; depending where that instruction is, 4 types of jumps are defined:</p><ol><li><p>Near jump (a.k.a intra-segment jump): target instruction is within the current code segment (the segment currently pointed to by the CS register).</p><p>A short jump is a near jump whose target is within</p><p>limited to â€“128 to +127 from the current <code>EIP</code> value.</p></li><li><p>Far jump: A jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.</p></li><li><p>Task switch: A jump to an instruction located in a different task.</p></li></ol><ul><li><p><code>SETcc dest</code> (Set Byte on Condition cc)</p><p><code>dest</code> must be a 8-bit GP register or memory address of a byte. set <code>dest</code> byte (i.e. assign with 1) if condition <code>cc</code> is satisfied.</p><p><code>cc</code> includes:</p><ol><li><code>A</code> / <code>AE</code>: above / above or equal</li><li>&mldr;</li></ol></li><li><p><code>TEST a, b</code>: the same as <code>AND a,b</code>, except No write-back of the result.</p></li></ul><p>Jumps: these spelled instruction in assembly source code has different opcodes implementation, depending on the addressing nature of the operand.</p><ul><li><p><code>JMP operand</code>: one-way unconditional transfer of control.</p><p>Different opcode implementations exist depending on the nature of <code>operand</code>:</p><ul><li><p>direct jump: <code>EIP = EIP + operand</code></p><p>Direct jump happens when <code>operand</code> is an immediate number. A direct jump is always a near jump (i.e. in the same segment)
and <code>operand</code> is treated as a signed integer displacement relateive the current <code>EIP</code></p></li><li><p>indirect near jump: happens when <code>operand</code> nominates a GP register. <code>EIP = operand</code></p></li></ul><p>The stack is unmodified.</p></li><li><p><code>CALL operand</code>: <code>PUSH EIP + JMP operand</code>; save the current <code>EIP</code> (i.e. the address of the next instruction following the <code>CALL</code>) to stack for later use by a <code>RET</code> instruction, then do a jump.</p></li><li><p><code>RET</code>: <code>POP EIP</code></p></li></ul><p>unsigned conditionals jumps:</p><ul><li><code>JA/JNBE</code></li><li><code>JAE/JNB</code></li><li><code>JB/JNAE</code></li><li><code>JBE/JNA</code></li><li><code>JC</code></li><li><code>JE/JZ</code></li><li><code>JNC</code></li><li><code>JNE/JNZ</code></li><li><code>JNP/JPO</code></li><li><code>JP/JPE</code></li></ul><h2 id=todo>Signed Conditional jumps:
TODO:</h2><p>Loops</p><ul><li><code>LOOP label</code> (Loop While ECX Not Zero): first decrement <code>ECX</code>, then jump to label if <code>ECX</code> is not 0.</li><li><code>LOOPE/LOOPZ label</code> (Loop While Equal / Loop While Zero): mneomnics for the same instruction; first decrement <code>ECX</code>, then jump to label if <code>ECX</code> is not 0 and <code>ZF=1</code></li><li><code>LOOPNE/LOOPNZ label</code> (Loop While Not Equal / Loop While Not Zero): mneomnics for the same instruction; first decrement <code>ECX</code>, then jump to label if <code>ECX</code> is not 0 and <code>ZF=0</code></li></ul><p>loop helper</p><ul><li><code>JCXZ label</code> (Jump if ECX Zero): JCXZ is useful in combination with the
LOOP instruction and with the string scan and compare instructions, all of
which decrement ECX.</li></ul><h4 id=interrupts>Interrupts.</h4><p>Interrupts were first designed to be generated by hardware when certain exceptional condition is encountered,
e.g. invalid instruction or divide-by-zero. A system programmer is supposed to first setup the interrupt procedure table by &mldr;;</p><p>An interrupt is assigned a number and range <code>0-31</code> are non-maskable interrupts (NMI).</p><ul><li><code>INT n</code> (software interrupt): same as <code>CALL</code>, except that<ol><li><code>operand</code> is an index into the interrupt table from which the jump target address can be lookup-ed, rather than an offset of register.</li></ol></li><li><code>INTO</code> (interrupt on overflow): invokes <code>INT 4</code> if OF is set.</li><li><code>INT3</code> ()</li><li><code>BOUND register, addr</code> (Detect Value Out of Range): <code>addr</code> is dereferenced to get adjacently stored <code>lower</code> and <code>higher</code> numeric values; invoke <code>INT 5</code> if the signed value contained in <code>register</code> is out of the range.</li><li><code>IRET</code> (return from interrupt): same as <code>RET</code>, except that <code>EFLAGS</code> is also restored (i.e. <code>POP EFLAGS</code>)</li></ul><h2 id=strings-manipulations>Strings manipulations</h2><p>Indirect, indexed addressing, with automatic incrementing or decrementing of the indexes.</p><p>string manipulation state registers:</p><ul><li><code>ESI</code> &ndash; Source index register</li><li><code>EDI</code> &ndash; Destination index register</li></ul><p>The <code>DF</code> (Direction flag) register controls the direction of operation.</p><ul><li><code>CLD</code> &ndash; Clear direction flag instruction</li><li><code>STD</code> &ndash; Set direction flag instruction</li></ul><p>These instructions manipulate a string of bytes, words, or doublewords.
All of them copy from <code>DS:[ESI]</code> (<code>ESI</code> offset into <code>DS</code> segment) to <code>ES:[EDI]</code> (<code>EDI</code> offset into <code>ES</code> segment).</p><p>The ones without <code>[BWD]</code> suffix can take 2 memory address operands which can be very misleading, never use them:
both operands only tell the Intel assembler the correct size of the item to be copied (being 8/16/32-bit);
its address is simply ignored, and never get into the machine code.</p><p>Use zero-operand variants with <code>[BWD]</code> suffixes, e.g. <code>MOVSB</code>, <code>STOSD</code>, etc.
This allows more compact programs to be written.</p><ul><li><code>MOVS dest, src</code> (Move String):<ul><li><code>MOVSB</code>: Move byte <code>DS:[(E)SI]</code> (overridable by a segment prefix)to <code>ES:[(E)DI]</code> (can&rsquo;t be overridden)</li><li><code>MOVSW</code>: Move word <code>DS:[(E)SI]</code> (overridable by a segment prefix)to <code>ES:[(E)DI]</code> (can&rsquo;t be overridden)</li><li><code>MOVSD</code>: Move dword <code>DS:[(E)SI]</code> (overridable by a segment prefix)to <code>ES:[(E)DI]</code> (can&rsquo;t be overridden)</li></ul></li><li><code>CMPS</code> (Compare string):</li><li><code>SCAS</code> (Scan string):</li><li><code>LODS</code> (Load string):</li><li><code>STOS</code> (Store string):</li></ul><p>The following prefixes can be applied as alternatives to an explicit loop structure:</p><ul><li><code>REP</code> (Repeat while ECX not zero):</li><li><code>REPE/REPZ</code> (Repeat while equal or zero):</li><li><code>REPNE/REPNZ</code> (Repeat while not equal or not zero):</li></ul><h3 id=administrative>Administrative</h3><h4 id=verification-of-pointer-parameters>Verification of pointer parameters:</h4><ul><li><code>ARPL</code> &ndash; Adjust RPL</li><li><code>LAR</code> &ndash; Load Access Rights</li><li><code>LSL</code> &ndash; Load Segment Limit</li><li><code>VERR</code> &ndash; Verify for Reading</li><li><code>VERW</code> &ndash; Verify for Writing</li></ul><h4 id=addressing-descriptor-tables-refer-to-chapter-5>Addressing descriptor tables (refer to Chapter 5):</h4><ul><li><code>LLDT</code> &ndash; Load LDT Register</li><li><code>SLDT</code> &ndash; Store LDT Register</li><li><code>LGDT</code> &ndash; Load GDT Register</li><li><code>SGDT</code> &ndash; Store GDT Register</li></ul><h4 id=multitasking>Multitasking</h4><ul><li><code>LTR</code> &ndash; Load Task Register</li><li><code>STR</code> &ndash; Store Task Register</li></ul><h4 id=coprocessing-and-multiprocessing-refer-to-chapter-11>Coprocessing and Multiprocessing (refer to Chapter 11):</h4><ul><li><code>CLTS</code> &ndash; Clear Task-Switched Flag</li><li><code>ESC</code> &ndash; Escape instructions</li><li><code>WAIT</code> &ndash; Wait until Coprocessor not Busy</li><li><code>LOCK</code> &ndash; Assert Bus-Lock Signal</li></ul><h4 id=input-and-output-refer-to-chapter-8>Input and Output (refer to Chapter 8):</h4><ul><li><code>IN</code> &ndash; Input</li><li><code>OUT</code> &ndash; Output</li><li><code>INS</code> &ndash; Input String</li><li><code>OUTS</code> &ndash; Output String</li></ul><h4 id=interrupt-control-refer-to-chapter-9>Interrupt control (refer to Chapter 9):</h4><ul><li><code>CLI</code> &ndash; Clear Interrupt-Enable Flag</li><li><code>STI</code> &ndash; Set Interrupt-Enable Flag</li><li><code>LIDT</code> &ndash; Load IDT Register</li><li><code>SIDT</code> &ndash; Store IDT Register</li></ul><h4 id=debugging-refer-to-chapter-12>Debugging (refer to Chapter 12):</h4><p>MOV &ndash; Move to and from debug registers</p><h4 id=tlb-testing-refer-to-chapter-10>TLB testing (refer to Chapter 10):</h4><p>MOV &ndash; Move to and from test registers</p><h2 id=system-control>System Control:</h2><ul><li><code>SMSW / LMSW</code>: Set/ Load MSW; since 80386 the MSW register can be accessed by <code>MOV dest, CR0</code>, and these 2 instructions are only provided for compatibility.</li><li><code>HLT</code> &ndash; Halt Processor; stops the processor until receipt of an INTR or RESET signal.</li><li><code>MOV</code> &ndash; Move to and from control registers</li></ul></div></article></main><footer>Unless otherwise noted, content of this site is licensed under
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ style=text-decoration:underline>the CC BY-NC-SA 4.0</a>.<br>cesun.info copyright 2024.</footer></body></html>