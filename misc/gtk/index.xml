<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GTK on Infinity Architect</title><link>https://cesun.info/misc/gtk/</link><description>Recent content in GTK on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 23 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/misc/gtk/index.xml" rel="self" type="application/rss+xml"/><item><title>GObject</title><link>https://cesun.info/misc/gtk/gobject/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/misc/gtk/gobject/</guid><description>Misc Gobject is single-inherited.
To register a custom type Bar in project Foo, usually you need to define a struct FooBar and a struct FooBarClass.
The prior is known as the instance struct, which contains fields that actually make up the size of each instance of your type. The later is known as the class structs, which holds &amp;ldquo;member functions&amp;rdquo;, i.e. pointers-to-functions. Custom types that follow the above conventions are said to be &amp;ldquo;classed&amp;rdquo; type, i.</description></item><item><title/><link>https://cesun.info/misc/gtk/glib-misc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cesun.info/misc/gtk/glib-misc/</guid><description>The main event loop GSource instances represent event source of all possible kinds.
A GtkMainContext instance is associated with multiple GSources by calling g_source_attach(source, context).
One creates a GMainLoop instance out of a GtkMainContext. Calling g_main_loop_run() on it will keep polling on all GSource s and dispatching control flow to correct handler.
GSource Each GSource instance consists of 4 functions, defined by GSourceFuncs. They will be frenquently queried by the main loop:</description></item><item><title/><link>https://cesun.info/misc/gtk/gobject/macro-internals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cesun.info/misc/gtk/gobject/macro-internals/</guid><description>Final type combos G_DECLARE_FINAL_TYPE() DECLARED foo_bar_get_type(void) G_DEFINE_TYPE in .c file will provide the implementation By convention, users are expected to #define FOO_TYPE_BAR foo_bar_get_type() typedef imcomplete struct _FooBar to FooBar; expecting user to define struct _FooBar later. a complete anonymous struct to FooBarClass. The struct holds only a ParentObjectClass field. DEFINED FooBar* FOO_BAR(gpointer) pointer-to-instance casting function gboolean FOO_IS_BAR(gpointer) pointer-to-instance runtime type check Plus, instance struct &amp;amp; class struct internal typedefs and freeing functions implementation.</description></item><item><title/><link>https://cesun.info/misc/gtk/gobject/misc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cesun.info/misc/gtk/gobject/misc/</guid><description>final type
Doesn&amp;rsquo;t have field in its class struct other than its parent class struct. Boundary btw. GType and GObject GType handles:
type metadata registration via struct GTypeInfo and g_type_register_static() / g_type_register_dynamic().</description></item><item><title/><link>https://cesun.info/misc/gtk/gobject/signal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cesun.info/misc/gtk/gobject/signal/</guid><description>Signal GType ships a simple pub-sub mechanism called signal.
All GTypes can have signal associated with it. You don&amp;rsquo;t need GObject or its subclass to enjoy this feature.
declare acceptable signal name Each class (type) T , during initialization, declare the &amp;ldquo;signals&amp;rdquo; (simply a name string) that instances of T can handle via g_signal_new*() family.
All of them eventually calls g_signal_newv(), register signal handler Party A registers one or more callbacks, known as &amp;ldquo;signal handler&amp;rdquo;, for the signal on a specific instance of T via g_signal_connect*() family.</description></item></channel></rss>