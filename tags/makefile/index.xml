<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Makefile on Infinity Architect</title><link>https://cesun.info/tags/makefile/</link><description>Recent content in Makefile on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 25 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/tags/makefile/index.xml" rel="self" type="application/rss+xml"/><item><title>Make - Performance Consideration</title><link>https://cesun.info/cxx/make/performance/</link><pubDate>Sun, 31 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/make/performance/</guid><description>prevent useless rules from getting into the intermediate form 1 2# figure out when it&amp;#39;s necessary to active certain rule 3# and guard heavy rules with the variable 4 5ifdef may-sync-config 6 7# a heavy rule that depends on more than 1500 files 8# unconditionally have this rule will cause make to `stat` each dependency files 9heavy_rule: foo bar ... 10 11# or put in an separate file for clarity 12include include/config/auto.</description></item><item><title>Sub-Make</title><link>https://cesun.info/cxx/make/submake/</link><pubDate>Fri, 22 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/make/submake/</guid><description>The term sub-make refers to the practice of having a recipe (executed by your shell) that fork-exec another make process.
Of course, you can do this by:
1do-submake: 2 cd submodule &amp;amp;&amp;amp; make copy That&amp;rsquo;s it. There is no more magic in the term sub-make.
The recipe is completely interpreted by the shell: cd into another directory and run a make. However, the rule above indeed has some flaws, although not absurdly wrong.</description></item><item><title>On the Build System of Linux Kernel</title><link>https://cesun.info/linux/kernel/build/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/build/</guid><description>&lt;p>This article analyzes the building process of the Linux kernel, including the implementation of &lt;code>Makefile&lt;/code>s. Various build-time generated files and build techniques are discussed.&lt;/p>
&lt;p>It is well-known that the Linux kernel should be built by &lt;code>make *config&lt;/code> followed by a &lt;code>make&lt;/code> call without a goal.
The &lt;code>make *config&lt;/code> command does nothing more than invoke a wizard program, which may include compiling that wizard program first.
It&amp;rsquo;s the wizard program&amp;rsquo;s responsibility to properly generate a &lt;code>.config&lt;/code> file which holds the user&amp;rsquo;s choice on the kernel building configs.&lt;/p></description></item><item><title>Makefile as a Dependency Description Language</title><link>https://cesun.info/cxx/make/dependency/</link><pubDate>Wed, 09 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/make/dependency/</guid><description>&lt;ul>
&lt;li>&lt;a href="https://www.gnu.org/software/make/manual/html_node/Double_002dColon.html">https://www.gnu.org/software/make/manual/html_node/Double_002dColon.html&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html">https://www.gnu.org/software/make/manual/html_node/Remaking-Makefiles.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>Makefile&lt;/code> language can be divided into 2 parts, a dependency description language,
and a scripting language including constructs like functions, variables, loops, branching etc.&lt;/p>
&lt;p>This article discusses everything about the Dependency Description ability of a Makefile.
See &lt;a href="#TODO">TODO&lt;/a> for the scripting part.&lt;/p></description></item><item><title>Makefile Variables</title><link>https://cesun.info/cxx/make/variables/</link><pubDate>Mon, 24 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/make/variables/</guid><description>Define variables the lazy flavor: recursively expanded variable The good old syntax are supported by all ancient make programs.
syntax: foo = RHS
Lazy expansion: foo stored RHS verbatim, without caring what it even is. foo expands to RHS upon request, and if RHS further contains variable reference, it will be recursively expanded. e.g. The following prints hello upon make. Notice the text order of variables:
1foo = $(bar) # foo stores literal string &amp;#39;$(bar)&amp;#39; 2bar = $(ugh) # bar stores literal string &amp;#39;$(ugh)&amp;#39; 3ugh = hello 4 5# recursive expansion happens when evaluating $(foo) 6all: 7	@echo $(foo) # &amp;#39;hello&amp;#39; copy the greedy flavor: simply expanded variables Require modern make implementations.</description></item><item><title>Makefile Overview</title><link>https://cesun.info/cxx/make/overview/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/make/overview/</guid><description>The Makefile language can be divided into 2 parts, a dependency description language, and a scripting language including constructs like functions, variables, loops, branching etc.
The purpose of the scripting part of a Makefile is to
determine the value of variables at run time, which can be expanded in the dependency part. conditionally enable or disable certain rules in the dependency part The mixture of 2 languages in the same Makefile renders it a rather weird creature for beginners.</description></item></channel></rss>