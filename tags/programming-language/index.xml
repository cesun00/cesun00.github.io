<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming Language on Infinity Architect</title><link>https://cesun.info/tags/programming-language/</link><description>Recent content in Programming Language on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 12 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/tags/programming-language/index.xml" rel="self" type="application/rss+xml"/><item><title>The `=delete` and `=default` Function Definition</title><link>https://cesun.info/cxx/lang/delete-default-func/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/delete-default-func/</guid><description>&lt;p>This article discussed the &lt;code>= default&lt;/code> and the &lt;code>= delete&lt;/code> syntax, both of which serve as a function definition, not declaration.&lt;/p></description></item><item><title>SFINAE, aghhhh</title><link>https://cesun.info/cxx/lang/template/sfinae/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/sfinae/</guid><description>&lt;h2 id="plain-function-overloads-in-a-world-without-template">plain function overloads in a world without template&lt;/h2>
&lt;p>In a world without template, When a function call expression (as described in&lt;code>[expr.call]&lt;/code>) is encountered,
compiler performs 2 steps to eventually determine which function to call.&lt;/p></description></item><item><title>Spell That Declaration Correctly!</title><link>https://cesun.info/cxx/lang/cdecl/</link><pubDate>Fri, 22 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/cdecl/</guid><description>Don&amp;rsquo;t mix pointers and non-pointers in the same declaration 1// do 2int *ptr_a, *ptr_b; 3int c; 4 5// don&amp;#39;t 6int* ptr_a, b; copy pointer to const vs. const pointer 1const int *ptr_a;	// pointer to const 2int *const ptr_b;	// const pointer; Recommended: asterisk preceeds const immediately copy a pointer to array vs. array of pointers 1int (*ptr_to_arr)[42]; // Pointer to an array 2int *ptr_arr[42]; // Array of pointers. copy 2d Array on Heap 1/** 2 * @brief 2D array malloc with compilation-time known size.</description></item><item><title>GNU CPP: the C/C++ Preprocessor</title><link>https://cesun.info/cxx/lang/preprocessor/</link><pubDate>Sat, 25 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/preprocessor/</guid><description>&lt;p>GCC C/C++ shares the same preprocessor program &lt;code>cpp&lt;/code>. Several of its primary functionalities are discussed.&lt;/p></description></item><item><title>C++ Initialization Types</title><link>https://cesun.info/cxx/lang/init/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/init/</guid><description>&lt;p>Initialization in C++ happens&lt;/p>
&lt;ol>
&lt;li>as an optional part of a variable declaration that gives it an initial value.&lt;/li>
&lt;li>when an expression as a function argument is bound to a function parameter&lt;/li>
&lt;li>when an expression after function &lt;code>return&lt;/code> is bound to the returned entity (received by caller or not)&lt;/li>
&lt;/ol>
&lt;p>The latter 2 can be equivalently viewed as a variable declaration with &lt;code>initializer&lt;/code> in an obvious way.
We&amp;rsquo;ll be focusing on the first scenario, which is the only hard part.&lt;/p>
&lt;p>This article discusses various initialization syntax and their behavior in terms of C++ specification.
A comparison with C is given.&lt;/p></description></item><item><title>Memorandum on C++ Specification</title><link>https://cesun.info/cxx/lang/spec/</link><pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/spec/</guid><description>Named Requirements Pre-C++20 versions lack the syntatic expressiveness to put explicit restriction on type template argument. A template parameter takes whatever arguments provided, and the compiler doesn&amp;rsquo;t complain until the instantiation makes an ill-formed program (including static_assert failure), i.e. compile-time duck typing.
When standard text needs to describe certain contract on template arguments with user programmer, the word named requirement is coined to refer to such contract. Examples are
std::find_if can be instantiated with whatever (deduced) type argument, but you get an ill-formed instantiation unless the first and second argument Since C++20,</description></item><item><title>Member templates</title><link>https://cesun.info/cxx/lang/template/member-template/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/member-template/</guid><description>A member template is a function / class / variable / alias template that appears inside the member-specification of the class (i.e. class body).
All instantiations of member templates have equal member access as their non-template counterparts. The static semantics applies normally. Member templates are different creatures than other members, in that their code is compiled at client side (or for metaprogramming code, evaluated at client&amp;rsquo;s compiler).
Class members are fixed once library author released the binaries and headers.</description></item><item><title>Overview of C++ Template</title><link>https://cesun.info/cxx/lang/template/overview/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/overview/</guid><description>&lt;p>Essentially, the template system in C++ is an advanced macro processor.
Arbitrary textual program sources can be generated via the instantiation of a template.
Depending on the role of the generated construct, there are&lt;/p></description></item><item><title>Overview: The Class Construct</title><link>https://cesun.info/cxx/lang/class/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/class/</guid><description>constructor Within a class member specification, the declaration of a non-static, non-template member function is a constructor declaration if
1struct S { 2 S(); // declares the constructor 3}; 4 5S::S() { } // defines the constructor copy The constructor is considered a function with no name.
Special Member Functions (SMF) (c++20 11.4.3.1) A class have
at most 1 default constructor, at most 1 copy constructor, at most 1 move constructor, at most 1 copy assignment operator, at most 1 move assignment operator, and prospective destructors all of which are known as special member functions of that class.</description></item><item><title>Value Category and Move Semantics</title><link>https://cesun.info/cxx/lang/move/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/move/</guid><description>Value category is a property of an expression. Prior to C++11, the specification only identifies 2 value categories:
lvalue: roughly means expressions that can appear on the left-hand side of assignment operator =
rvalue: roughly means expressions that cannot
As a special case, all function calls in C are rvalue, thus puts(&amp;quot;foo&amp;quot;) = 42 is illegal. But the introduction of reference in C++ breaks the game, foo() = 42 is valid if foo returns a non-const reference.</description></item><item><title>Static Initialization Fiasco</title><link>https://cesun.info/cxx/lang/static-init/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/static-init/</guid><description>Static Initialization TLDR: don&amp;rsquo;t use non-pointer static variables at all.
Within a single translation unit, static variables are guaranteed to be initialized from top to bottom. You can let the initializer of a static variable depend on a previous one, in a single translation unit:
1static int foo = 42; // live in .data 2static int bar; // live in .bss 3static int zoo = foo + bar + 42; // live in .</description></item><item><title>Variadic Arguments in C/C++</title><link>https://cesun.info/cxx/lang/variadic/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/variadic/</guid><description>Variadic Macro Functions Preprocessors of gcc and clang supports variadic macro function. This feature is mandatory since C99 / C++11.
1// An ellipsis as the last macro parameter becomes the sink. 2// Use `__VA_ARGS__` to refer to whatever token sequence the sink accepts. 3#define foo(...) real_foo(42, __VA_ARGS__) 4 5// GNUCPP-specific named sink: 6#define foo(bar...) real_foo(42, bar) 7 8// Preceding normal arguments are allowed, with some problems 9#define eprintf(format, ...) std::fprintf(stderr, format, __VA_ARGS__) 10 11eprintf(&amp;#34;hooray!</description></item><item><title>C++ Metaprogramming</title><link>https://cesun.info/cxx/lang/template/meta-programming/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/meta-programming/</guid><description>Metaprogramming in C++ refer to the exercise of writting bool constexpr evaluated by the client compiler, such that correct template instantiation is eventually instantiated.
check if T is not const or volatile 1std::same_as&amp;lt;T, std::remove_cv_t&amp;lt;T&amp;gt;&amp;gt; copy Use std::addressof to take address of object Work against overloaded operator&amp;amp;.
Use std::to_address to get the address value of (smart / raw) pointers 1#include &amp;lt;type_traits&amp;gt; 2#include &amp;lt;memory&amp;gt; 3#include &amp;lt;cstdio&amp;gt; 4 5int main () { 6 // std::toaddress 7 // 1) work for both smart and raw pointer 8 auto int_up = std::make_unique&amp;lt;int&amp;gt;(42); 9 int *int_p = new int{22}; 10 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(int_up)); 11 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(int_p)); 12 13 // 2) avoid the trap of std::addressof(*ptr) 14 int *wild_int_p = int_p + 10000000; // pointer arithmetic is well-defined behavior 15 //std::printf(&amp;#34;%p\n&amp;#34;, std::addressof(*wild_int_p)); // undefined behavior 16 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(wild_int_p)); // ok 17 18 delete int_p; 19} copy https://stackoverflow.</description></item><item><title>Introduction to C++20 Concept</title><link>https://cesun.info/cxx/lang/template/concept/</link><pubDate>Sun, 27 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/concept/</guid><description>Prior to C++20, type parameters in a template definition are introduced with template&amp;lt;typename T&amp;gt; ..., where T can bind to any existing type as long as the resulting code compiles. There is no way for a client programmer, upon seeing the template definition in a header file, to know what types can be used as arguments to the template other than reading the document.
Concepts is a C++20 feature that restricts, at the language level, the set of types that can be used as a type argument to a template.</description></item><item><title>Exception Infrastructure in C++</title><link>https://cesun.info/cxx/lang/exception/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/exception/</guid><description>C++ allows an instance of arbitrary type to be thrown as exception. But always only throw liskov-able subclass of std::exception.
Throw by value, catch by reference (preferably to-const).
1try { 2 // ... somewhere potentially deep down the calling stack 3 throw std::DerivedException{}; 4} catch(const std::BaseException &amp;amp;e) { 5 // handle polymorphic e 6} copy catch(...) is the syntax to catches everything, and caught object can&amp;rsquo;t be referred. This should be seldom useful if (2) is followed.</description></item><item><title>Miscellaneous C++ consideration</title><link>https://cesun.info/cxx/misc/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/misc/</guid><description>Ownership Ownership of resources is the responsibility to destroy those resources at proper time.
In any design, resource owning class should follow RAII, and follow the Single Resonsibility Principle: it shouldn&amp;rsquo;t have any public API other than
the 6 reasonable special member functions a raw resourece accessor, as described in scott&amp;rsquo;s Item 15: Provide access to raw resources in resource-managing classes. use make_(unique|shared) helpers instead of smart pointer constructor https://stackoverflow.com/a/22571331/8311608</description></item><item><title>Function Template</title><link>https://cesun.info/cxx/lang/template/function-template/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/function-template/</guid><description>Canonically, a function template &amp;hellip;
&amp;hellip; is declared by 1template&amp;lt;typename T&amp;gt; 2void foo(T); copy C++20 allows a function declaration to have placeholder type (i.e. auto) or constrained placeholder type (i.e. constrained auto) as an equivalent syntax of function template declaration with type parameter:
1// equivalent to above 2void foo(auto); copy &amp;hellip; is defined by 1template&amp;lt;typename T&amp;gt; 2void foo(T) {/**/} copy In most cases, the definition part of a function template is trivial, and doesn&amp;rsquo;t affect the templating resolution or metaprogramming magic at all.</description></item><item><title>Template Specialization</title><link>https://cesun.info/cxx/lang/template/specialization/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/specialization/</guid><description>Specialization allows a complete different template definition to be used when specific 1) template arguments, or 2) patterns of template arguments is provided.
is the case for both full and partial specialization is more expressive, and is only the case for partial specialization. Specialization embodies ad-hoc polymorphism of metaprogramming: the same template name (interface) works for different type by really having multiple templates definition. It resembles function overloads, and is the the metaprogramming counterpart of the latter in many ways.</description></item><item><title>Template Parameters</title><link>https://cesun.info/cxx/lang/template/template-parameter/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/template-parameter/</guid><description>This article documents C++ features related to parameterized templates, common for all of function / class / whatever templates.
Template Parameters A template declares its parameters list in a pair of angle brackets. There are 3 types of template parameters:
type template parameter receives a type identifier as argument
It&amp;rsquo;s led by a typename or a class keyword:
1template&amp;lt;typename T&amp;gt; 2class Container&amp;lt;T&amp;gt; {} copy type template parameter can be constrained, in which case it&amp;rsquo;s led by concept name:</description></item><item><title>Copy / Move Elision and Return Value Optimization (RVO)</title><link>https://cesun.info/cxx/lang/copy-elision-and-rvo/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/copy-elision-and-rvo/</guid><description>Copy / Move Elision During a function call, copies may occur multiple times for arguemnts and function return:
1class X { 2public: 3 X(): id{&amp;#34;unknown&amp;#34;} {std::puts(&amp;#34;default ctor&amp;#34;);} 4 X(const std::string id): id{id} {std::puts(&amp;#34;ctor with given id&amp;#34;);} 5 X(const X &amp;amp;other): id{other.id} {std::puts(&amp;#34;copy ctor&amp;#34;);} 6 X(X &amp;amp;&amp;amp;other): id{std::move(other.id)} {std::puts(&amp;#34;move ctor&amp;#34;);} 7 ~X(){std::puts(&amp;#34;dtor&amp;#34;);} 8private: 9 std::string id; 10}; 11 12void foo(X gg) { } 13 14X bar() { 15 std::string id{/* e.g. get id from RPC connection */}; 16 return X{id}; 17} 18 19X zoo() { 20 X named{&amp;#34;zoo - named&amp;#34;}; 21 return named; 22} 23 24int main() { 25 X gg = zoo(); 26} copy [, c++17) gcc stop eliding copy / move ctors when -std=c++14 -fno-elide-constructors.</description></item><item><title>C++ Idioms Collections</title><link>https://cesun.info/cxx/lang/idioms/</link><pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/idioms/</guid><description>&lt;p>Some C++ Idioms collected. Use this article as a cheetsheet.&lt;/p></description></item><item><title>Class Template</title><link>https://cesun.info/cxx/lang/template/class-template/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/class-template/</guid><description>Class Template Argument Deduction (CTAD) (c++17) TODO: CTAD happends through FTAD on class&amp;rsquo;s ctor?
misc Mind static data member in class template All instantiations of a class template with the same template arguments share the same memory of data member:
1#include &amp;lt;cstdio&amp;gt; 2 3template&amp;lt;int N&amp;gt; 4struct Foo { 5 static int data[N]; 6}; 7 8template&amp;lt;int N&amp;gt; int &amp;lt;MAXN&amp;gt;::data[N]; 9 10int main() { 11 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 12 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 13 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 14 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 15} copy</description></item><item><title>Inline Static Function</title><link>https://cesun.info/cxx/lang/inline-static-function/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/inline-static-function/</guid><description>&lt;p>In 95% of the scenarios, using &lt;code>inline static&lt;/code> function with implementation in a header file is what you should do when you want to inline calls to a function; (there is no function anymore, just a code snippet copied and pasted)&lt;/p>
&lt;p>The situation gets a little bit complicated if you want or have to separate the declaration and definition of a function,
or want to know how and why of this practice.&lt;/p></description></item></channel></rss>