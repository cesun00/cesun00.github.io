<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Template on Infinity Architect</title><link>https://cesun.info/tags/template/</link><description>Recent content in Template on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 15 Jun 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/tags/template/index.xml" rel="self" type="application/rss+xml"/><item><title>Overview of C++ Template</title><link>https://cesun.info/cxx/lang/template/overview/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/overview/</guid><description>&lt;p>Essentially, the template system in C++ is an advanced macro processor.
Arbitrary textual program sources can be generated via the instantiation of a template.
Depending on the role of the generated construct, there are&lt;/p></description></item><item><title>Function Template</title><link>https://cesun.info/cxx/lang/template/function-template/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/function-template/</guid><description>Canonically, a function template &amp;hellip;
&amp;hellip; is declared by 1template&amp;lt;typename T&amp;gt; 2void foo(T); copy C++20 allows a function declaration to have placeholder type (i.e. auto) or constrained placeholder type (i.e. constrained auto) as an equivalent syntax of function template declaration with type parameter:
1// equivalent to above 2void foo(auto); copy &amp;hellip; is defined by 1template&amp;lt;typename T&amp;gt; 2void foo(T) {/**/} copy In most cases, the definition part of a function template is trivial, and doesn&amp;rsquo;t affect the templating resolution or metaprogramming magic at all.</description></item><item><title>Template Specialization</title><link>https://cesun.info/cxx/lang/template/specialization/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/specialization/</guid><description>Specialization allows a complete different template definition to be used when specific 1) template arguments, or 2) patterns of template arguments is provided.
is the case for both full and partial specialization is more expressive, and is only the case for partial specialization. Specialization embodies ad-hoc polymorphism of metaprogramming: the same template name (interface) works for different type by really having multiple templates definition. It resembles function overloads, and is the the metaprogramming counterpart of the latter in many ways.</description></item><item><title>Class Template</title><link>https://cesun.info/cxx/lang/template/class-template/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/class-template/</guid><description>Class Template Argument Deduction (CTAD) (c++17) TODO: CTAD happends through FTAD on class&amp;rsquo;s ctor?
misc Mind static data member in class template All instantiations of a class template with the same template arguments share the same memory of data member:
1#include &amp;lt;cstdio&amp;gt; 2 3template&amp;lt;int N&amp;gt; 4struct Foo { 5 static int data[N]; 6}; 7 8template&amp;lt;int N&amp;gt; int &amp;lt;MAXN&amp;gt;::data[N]; 9 10int main() { 11 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 12 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 13 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 14 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 15} copy</description></item></channel></rss>