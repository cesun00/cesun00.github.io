<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on Infinity Architect</title><link>https://cesun.info/tags/c++/</link><description>Recent content in C++ on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 20 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>STLv2</title><link>https://cesun.info/cxx/std/stlv2/</link><pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/stlv2/</guid><description>infrastructures Core concept ranges::range T satisfies range if ranges:begin(t) and ranges::end(t) compiles, where t is lvalue expression of type T.
e.g. Both vector&amp;lt;int&amp;gt; and vector&amp;lt;int&amp;gt;&amp;amp; satisfies range.
Core concept ranges::view Every view is range.
view captures a non-reference type T that satisfies range, plus its copy ctor (if exist), copy= (if exist), move ctor (must exist), move= (must exist) all work in O(1). e.g. std::string_view satisfies view, but std::string_view &amp;amp; does not.</description></item><item><title>Smart Pointers</title><link>https://cesun.info/cxx/std/smart-pointers/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/smart-pointers/</guid><description>When not to use smart pointer Guideline:
raw pointer with new expression is always bad. there are situation in modern C++ where raw pointers make perfect sense. when destruction of resources is potentially-throwing Exception can&amp;rsquo;t be thrown from deleter. Use classic RAII class with noexcept(false) public API and noexcept(true) dtor instead of smart pointer.
https://stackoverflow.com/questions/130117/if-you-shouldnt-throw-exceptions-in-a-destructor-how-do-you-handle-errors-in-i
RAII class should be kept simple: never own 2 resources in 1 class.
Microsoft guide mentioned this (TODO: Bad things happends when RAII class wraps 2 resources?</description></item><item><title>C++ Randomness Infrastructure</title><link>https://cesun.info/cxx/std/random/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/random/</guid><description>Support for randomness was introduced since C++11. Its design revolves around the following types of templates / classes / concepts:
Concept std::uniform_random_bit_generator Concept std::uniform_random_bit_generator models (class of) URBG (uniform random bit generators).
An URBG is a functor
whose operator() returns a sequence of uniformly random bits in the form of an unsigned integral value. (i.e. the returned integer is also uniform within min() and max()) whose class has min() and max() static member functions and they make sense.</description></item><item><title>The `=delete` and `=default` Function Definition</title><link>https://cesun.info/cxx/lang/delete-default-func/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/delete-default-func/</guid><description>&lt;p>This article discussed the &lt;code>= default&lt;/code> and the &lt;code>= delete&lt;/code> syntax, both of which serve as a function definition, not declaration.&lt;/p></description></item><item><title>Linux Randomness APIs</title><link>https://cesun.info/linux/random-api/</link><pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/random-api/</guid><description>C99 rand() and srand() Range: [0, RAND_MAX]
POSIX random() and srandom() Range: [0,2^31 - 1]
No standard specifies the distribution, though common implementations seems to be uniform. (don&amp;rsquo;t rely on that) credit.
POSIX rand48 family Uniform distribution random integer &amp;amp; float number generation.
&amp;ldquo;48&amp;rdquo; in those names indicates their nature of linear congruential algorithm with 48-bit modular arithmetic.
Such algorithms generate next random number sequence by recursively:
X_{n+1} = (a * X_n + c) % m copy The choice of (m, a, c) choice differs among implementations and papers.</description></item><item><title>The clang-format Formatter</title><link>https://cesun.info/cxx/clang/clang-format/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/clang/clang-format/</guid><description>1clang-format [options] &amp;lt;source files ...&amp;gt; copy Supported coding style preset: LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit
ClangFormat respects a collection of format options, whose fallback values are specified by --fallback-style= options, which defaults to LLVM.
These format options are further overridden depending on the value of --style= CLI option, which defaults to file if omitted:
file: file .clang-format is searched in the containing directories of each given &amp;lt;source files&amp;gt;.</description></item><item><title>SFINAE, aghhhh</title><link>https://cesun.info/cxx/lang/template/sfinae/</link><pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/sfinae/</guid><description>&lt;h2 id="plain-function-overloads-in-a-world-without-template">plain function overloads in a world without template&lt;/h2>
&lt;p>In a world without template, When a function call expression (as described in&lt;code>[expr.call]&lt;/code>) is encountered,
compiler performs 2 steps to eventually determine which function to call.&lt;/p></description></item><item><title>Spell That Declaration Correctly!</title><link>https://cesun.info/cxx/lang/cdecl/</link><pubDate>Fri, 22 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/cdecl/</guid><description>Don&amp;rsquo;t mix pointers and non-pointers in the same declaration 1// do 2int *ptr_a, *ptr_b; 3int c; 4 5// don&amp;#39;t 6int* ptr_a, b; copy pointer to const vs. const pointer 1const int *ptr_a;	// pointer to const 2int *const ptr_b;	// const pointer; Recommended: asterisk preceeds const immediately copy a pointer to array vs. array of pointers 1int (*ptr_to_arr)[42]; // Pointer to an array 2int *ptr_arr[42]; // Array of pointers. copy 2d Array on Heap 1/** 2 * @brief 2D array malloc with compilation-time known size.</description></item><item><title>Memo: Effective Modern C++ (Scott Meyers)</title><link>https://cesun.info/cxx/effective-modern-cxx/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/effective-modern-cxx/</guid><description>&lt;p>This is a memorandum on my walk through the Effective C++.
Most of these were written in Fall, 2020.&lt;/p></description></item><item><title>GNU CPP: the C/C++ Preprocessor</title><link>https://cesun.info/cxx/lang/preprocessor/</link><pubDate>Sat, 25 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/preprocessor/</guid><description>&lt;p>GCC C/C++ shares the same preprocessor program &lt;code>cpp&lt;/code>. Several of its primary functionalities are discussed.&lt;/p></description></item><item><title>C++ Initialization Types</title><link>https://cesun.info/cxx/lang/init/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/init/</guid><description>&lt;p>Initialization in C++ happens&lt;/p>
&lt;ol>
&lt;li>as an optional part of a variable declaration that gives it an initial value.&lt;/li>
&lt;li>when an expression as a function argument is bound to a function parameter&lt;/li>
&lt;li>when an expression after function &lt;code>return&lt;/code> is bound to the returned entity (received by caller or not)&lt;/li>
&lt;/ol>
&lt;p>The latter 2 can be equivalently viewed as a variable declaration with &lt;code>initializer&lt;/code> in an obvious way.
We&amp;rsquo;ll be focusing on the first scenario, which is the only hard part.&lt;/p>
&lt;p>This article discusses various initialization syntax and their behavior in terms of C++ specification.
A comparison with C is given.&lt;/p></description></item><item><title>C++ STL Container &amp; Iterator</title><link>https://cesun.info/cxx/std/container/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/container/</guid><description>C++ specification leaves the implementation of STL iterators to be vendor-defined.
1template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt; 2class vector { 3 using iterator = implementation-defined ; 4 using const_iterator = implementation-defined ; 5} copy vector over list https://stackoverflow.com/questions/2209224/vector-vs-list-in-stl#comment20988862_2209233 https://www.stroustrup.com/bs_faq.html#list
Bjarne Strostrup actually made a test where he generated random numbers and then added them to a list and a vector respectively. The insertions were made so that the list/vector was ordered at all times.</description></item><item><title>Memorandum on C++ Specification</title><link>https://cesun.info/cxx/lang/spec/</link><pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/spec/</guid><description>Named Requirements Pre-C++20 versions lack the syntatic expressiveness to put explicit restriction on type template argument. A template parameter takes whatever arguments provided, and the compiler doesn&amp;rsquo;t complain until the instantiation makes an ill-formed program (including static_assert failure), i.e. compile-time duck typing.
When standard text needs to describe certain contract on template arguments with user programmer, the word named requirement is coined to refer to such contract. Examples are
std::find_if can be instantiated with whatever (deduced) type argument, but you get an ill-formed instantiation unless the first and second argument Since C++20,</description></item><item><title>Member templates</title><link>https://cesun.info/cxx/lang/template/member-template/</link><pubDate>Thu, 09 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/member-template/</guid><description>A member template is a function / class / variable / alias template that appears inside the member-specification of the class (i.e. class body).
All instantiations of member templates have equal member access as their non-template counterparts. The static semantics applies normally. Member templates are different creatures than other members, in that their code is compiled at client side (or for metaprogramming code, evaluated at client&amp;rsquo;s compiler).
Class members are fixed once library author released the binaries and headers.</description></item><item><title>Memo: Effective C++ (Scott Meyers, 2006)</title><link>https://cesun.info/cxx/effective-cxx/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/effective-cxx/</guid><description>&lt;p>This is a memorandum on my walk through the Effective C++.
Most of these were written in Fall, 2020.
Sections that don&amp;rsquo;t hold anymore for new C++11 and later are removed.&lt;/p></description></item><item><title>Overview of C++ Template</title><link>https://cesun.info/cxx/lang/template/overview/</link><pubDate>Wed, 11 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/overview/</guid><description>&lt;p>Essentially, the template system in C++ is an advanced macro processor.
Arbitrary textual program sources can be generated via the instantiation of a template.
Depending on the role of the generated construct, there are&lt;/p></description></item><item><title>Overview: The Class Construct</title><link>https://cesun.info/cxx/lang/class/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/class/</guid><description>constructor Within a class member specification, the declaration of a non-static, non-template member function is a constructor declaration if
1struct S { 2 S(); // declares the constructor 3}; 4 5S::S() { } // defines the constructor copy The constructor is considered a function with no name.
Special Member Functions (SMF) (c++20 11.4.3.1) A class have
at most 1 default constructor, at most 1 copy constructor, at most 1 move constructor, at most 1 copy assignment operator, at most 1 move assignment operator, and prospective destructors all of which are known as special member functions of that class.</description></item><item><title>Value Category and Move Semantics</title><link>https://cesun.info/cxx/lang/move/</link><pubDate>Fri, 06 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/move/</guid><description>Value category is a property of an expression. Prior to C++11, the specification only identifies 2 value categories:
lvalue: roughly means expressions that can appear on the left-hand side of assignment operator =
rvalue: roughly means expressions that cannot
As a special case, all function calls in C are rvalue, thus puts(&amp;quot;foo&amp;quot;) = 42 is illegal. But the introduction of reference in C++ breaks the game, foo() = 42 is valid if foo returns a non-const reference.</description></item><item><title>MEMO: C++ Core Guidelines (CCG)</title><link>https://cesun.info/cxx/ccg/</link><pubDate>Wed, 27 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/ccg/</guid><description>https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
C.20: If you can avoid defining default operations, do. rule of zero:
Make a clear separation in mind between (1) resource-managing class, a.k.a (not precise, but) RAII class and (2) everything else (e.g. business related class) (1) should having no more public APIs other than the big 5, and optionally a raw resource getter. One seldom needs to write their own (1). STL containers and smart pointer with custom deleter should suffice.</description></item><item><title>Static Initialization Fiasco</title><link>https://cesun.info/cxx/lang/static-init/</link><pubDate>Tue, 26 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/static-init/</guid><description>Static Initialization TLDR: don&amp;rsquo;t use non-pointer static variables at all.
Within a single translation unit, static variables are guaranteed to be initialized from top to bottom. You can let the initializer of a static variable depend on a previous one, in a single translation unit:
1static int foo = 42; // live in .data 2static int bar; // live in .bss 3static int zoo = foo + bar + 42; // live in .</description></item><item><title>Variadic Arguments in C/C++</title><link>https://cesun.info/cxx/lang/variadic/</link><pubDate>Thu, 07 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/variadic/</guid><description>Variadic Macro Functions Preprocessors of gcc and clang supports variadic macro function. This feature is mandatory since C99 / C++11.
1// An ellipsis as the last macro parameter becomes the sink. 2// Use `__VA_ARGS__` to refer to whatever token sequence the sink accepts. 3#define foo(...) real_foo(42, __VA_ARGS__) 4 5// GNUCPP-specific named sink: 6#define foo(bar...) real_foo(42, bar) 7 8// Preceding normal arguments are allowed, with some problems 9#define eprintf(format, ...) std::fprintf(stderr, format, __VA_ARGS__) 10 11eprintf(&amp;#34;hooray!</description></item><item><title>C++ Metaprogramming</title><link>https://cesun.info/cxx/lang/template/meta-programming/</link><pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/meta-programming/</guid><description>Metaprogramming in C++ refer to the exercise of writting bool constexpr evaluated by the client compiler, such that correct template instantiation is eventually instantiated.
check if T is not const or volatile 1std::same_as&amp;lt;T, std::remove_cv_t&amp;lt;T&amp;gt;&amp;gt; copy Use std::addressof to take address of object Work against overloaded operator&amp;amp;.
Use std::to_address to get the address value of (smart / raw) pointers 1#include &amp;lt;type_traits&amp;gt; 2#include &amp;lt;memory&amp;gt; 3#include &amp;lt;cstdio&amp;gt; 4 5int main () { 6 // std::toaddress 7 // 1) work for both smart and raw pointer 8 auto int_up = std::make_unique&amp;lt;int&amp;gt;(42); 9 int *int_p = new int{22}; 10 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(int_up)); 11 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(int_p)); 12 13 // 2) avoid the trap of std::addressof(*ptr) 14 int *wild_int_p = int_p + 10000000; // pointer arithmetic is well-defined behavior 15 //std::printf(&amp;#34;%p\n&amp;#34;, std::addressof(*wild_int_p)); // undefined behavior 16 std::printf(&amp;#34;%p\n&amp;#34;, std::to_address(wild_int_p)); // ok 17 18 delete int_p; 19} copy https://stackoverflow.</description></item><item><title>Introduction to C++20 Concept</title><link>https://cesun.info/cxx/lang/template/concept/</link><pubDate>Sun, 27 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/concept/</guid><description>Prior to C++20, type parameters in a template definition are introduced with template&amp;lt;typename T&amp;gt; ..., where T can bind to any existing type as long as the resulting code compiles. There is no way for a client programmer, upon seeing the template definition in a header file, to know what types can be used as arguments to the template other than reading the document.
Concepts is a C++20 feature that restricts, at the language level, the set of types that can be used as a type argument to a template.</description></item><item><title>Exception Infrastructure in C++</title><link>https://cesun.info/cxx/lang/exception/</link><pubDate>Sun, 13 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/exception/</guid><description>C++ allows an instance of arbitrary type to be thrown as exception. But always only throw liskov-able subclass of std::exception.
Throw by value, catch by reference (preferably to-const).
1try { 2 // ... somewhere potentially deep down the calling stack 3 throw std::DerivedException{}; 4} catch(const std::BaseException &amp;amp;e) { 5 // handle polymorphic e 6} copy catch(...) is the syntax to catches everything, and caught object can&amp;rsquo;t be referred. This should be seldom useful if (2) is followed.</description></item><item><title>Miscellaneous C++ consideration</title><link>https://cesun.info/cxx/misc/</link><pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/misc/</guid><description>Ownership Ownership of resources is the responsibility to destroy those resources at proper time.
In any design, resource owning class should follow RAII, and follow the Single Resonsibility Principle: it shouldn&amp;rsquo;t have any public API other than
the 6 reasonable special member functions a raw resourece accessor, as described in scott&amp;rsquo;s Item 15: Provide access to raw resources in resource-managing classes. use make_(unique|shared) helpers instead of smart pointer constructor https://stackoverflow.com/a/22571331/8311608</description></item><item><title>Function Template</title><link>https://cesun.info/cxx/lang/template/function-template/</link><pubDate>Fri, 04 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/function-template/</guid><description>Canonically, a function template &amp;hellip;
&amp;hellip; is declared by 1template&amp;lt;typename T&amp;gt; 2void foo(T); copy C++20 allows a function declaration to have placeholder type (i.e. auto) or constrained placeholder type (i.e. constrained auto) as an equivalent syntax of function template declaration with type parameter:
1// equivalent to above 2void foo(auto); copy &amp;hellip; is defined by 1template&amp;lt;typename T&amp;gt; 2void foo(T) {/**/} copy In most cases, the definition part of a function template is trivial, and doesn&amp;rsquo;t affect the templating resolution or metaprogramming magic at all.</description></item><item><title>Compiler Builtins / Intrisics</title><link>https://cesun.info/cxx/compiler-builtins/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/compiler-builtins/</guid><description>Most of these builtins translate to a single x86 instruction.
bit manipulations count leading (most significant) 0 1int __builtin_clz (unsigned int) 2int __builtin_clzl (unsigned long) 3int __builtin_clzll (unsigned long long) copy count trailing (least significant) 0 1int __builtin_ctz (unsigned int) 2int __builtin_ctzl (unsigned long) 3int __builtin_ctzll (unsigned long long) 4 5int __builtin_ffs (int x) 6int __builtin_ffsl (long) 7int __builtin_ffsll (long long) copy count occurrences of 1 1int __builtin_popcount (unsigned int x) 2int __builtin_popcountl (unsigned long) 3int __builtin_popcountll (unsigned long long) copy</description></item><item><title>Template Specialization</title><link>https://cesun.info/cxx/lang/template/specialization/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/specialization/</guid><description>Specialization allows a complete different template definition to be used when specific 1) template arguments, or 2) patterns of template arguments is provided.
is the case for both full and partial specialization is more expressive, and is only the case for partial specialization. Specialization embodies ad-hoc polymorphism of metaprogramming: the same template name (interface) works for different type by really having multiple templates definition. It resembles function overloads, and is the the metaprogramming counterpart of the latter in many ways.</description></item><item><title>Testing in C/C++</title><link>https://cesun.info/cxx/testing/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/testing/</guid><description>&lt;p>JUnit and Mockito are the de-facto standard testing suites for Java; They are used by every company I know.
On the other side, there is hardly a standardized exercise for the C/C++ world on how software should be tested.&lt;/p>
&lt;p>This article is an overview of various testing methodologies for software / library written in C/C++.&lt;/p></description></item><item><title>GCC MISC</title><link>https://cesun.info/cxx/gcc/misc/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/gcc/misc/</guid><description>cc1 and cc1plus The output of gcc -v actually shows no invocation of the cpp preprocessor. Instead, cc1/cc1plus is invoked for both pre-processing and compilation of C/C++. My assumption is that those 2 programs fork-exec cpp.
GCC Developer Options -print-search-dirs
-print-sysroot
-print-prog-name
1gcc -print-prog-name=cc1 2/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1 copy Specs String The gcc executable is a driver program, invoking other executables, e.g. cc1, as and collect2 (a wrapper around ld) to do the real job.</description></item><item><title>Template Parameters</title><link>https://cesun.info/cxx/lang/template/template-parameter/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/template-parameter/</guid><description>This article documents C++ features related to parameterized templates, common for all of function / class / whatever templates.
Template Parameters A template declares its parameters list in a pair of angle brackets. There are 3 types of template parameters:
type template parameter receives a type identifier as argument
It&amp;rsquo;s led by a typename or a class keyword:
1template&amp;lt;typename T&amp;gt; 2class Container&amp;lt;T&amp;gt; {} copy type template parameter can be constrained, in which case it&amp;rsquo;s led by concept name:</description></item><item><title>Copy / Move Elision and Return Value Optimization (RVO)</title><link>https://cesun.info/cxx/lang/copy-elision-and-rvo/</link><pubDate>Wed, 12 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/copy-elision-and-rvo/</guid><description>Copy / Move Elision During a function call, copies may occur multiple times for arguemnts and function return:
1class X { 2public: 3 X(): id{&amp;#34;unknown&amp;#34;} {std::puts(&amp;#34;default ctor&amp;#34;);} 4 X(const std::string id): id{id} {std::puts(&amp;#34;ctor with given id&amp;#34;);} 5 X(const X &amp;amp;other): id{other.id} {std::puts(&amp;#34;copy ctor&amp;#34;);} 6 X(X &amp;amp;&amp;amp;other): id{std::move(other.id)} {std::puts(&amp;#34;move ctor&amp;#34;);} 7 ~X(){std::puts(&amp;#34;dtor&amp;#34;);} 8private: 9 std::string id; 10}; 11 12void foo(X gg) { } 13 14X bar() { 15 std::string id{/* e.g. get id from RPC connection */}; 16 return X{id}; 17} 18 19X zoo() { 20 X named{&amp;#34;zoo - named&amp;#34;}; 21 return named; 22} 23 24int main() { 25 X gg = zoo(); 26} copy [, c++17) gcc stop eliding copy / move ctors when -std=c++14 -fno-elide-constructors.</description></item><item><title>C++ Idioms Collections</title><link>https://cesun.info/cxx/lang/idioms/</link><pubDate>Sat, 08 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/idioms/</guid><description>&lt;p>Some C++ Idioms collected. Use this article as a cheetsheet.&lt;/p></description></item><item><title>Class Template</title><link>https://cesun.info/cxx/lang/template/class-template/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/template/class-template/</guid><description>Class Template Argument Deduction (CTAD) (c++17) TODO: CTAD happends through FTAD on class&amp;rsquo;s ctor?
misc Mind static data member in class template All instantiations of a class template with the same template arguments share the same memory of data member:
1#include &amp;lt;cstdio&amp;gt; 2 3template&amp;lt;int N&amp;gt; 4struct Foo { 5 static int data[N]; 6}; 7 8template&amp;lt;int N&amp;gt; int &amp;lt;MAXN&amp;gt;::data[N]; 9 10int main() { 11 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 12 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;120&amp;gt;::data); // 0x5d50b4264040 13 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 14 printf(&amp;#34;%p\n&amp;#34;, Foo&amp;lt;240&amp;gt;::data); // 0x5d50b4264220 15} copy</description></item><item><title>Inline Static Function</title><link>https://cesun.info/cxx/lang/inline-static-function/</link><pubDate>Fri, 07 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/inline-static-function/</guid><description>&lt;p>In 95% of the scenarios, using &lt;code>inline static&lt;/code> function with implementation in a header file is what you should do when you want to inline calls to a function; (there is no function anymore, just a code snippet copied and pasted)&lt;/p>
&lt;p>The situation gets a little bit complicated if you want or have to separate the declaration and definition of a function,
or want to know how and why of this practice.&lt;/p></description></item><item><title>Fast Lexical Analyzer (Flex)</title><link>https://cesun.info/linux/flex/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/flex/</guid><description>The original lex program was written for the UNOS operating system in 1975. It was a proprietary software under the Bell Laboratories license. Nowadays open-source versions of lex based on the original proprietary code are available.
Flex is the free and open-source alternative to lex.
Vern Paxson took over the Software Tools lex project from Jef Poskanzer in 1982. At that point it was written in Ratfor. Around 1987 or so, Paxson translated it into C, and a legend was born :-).</description></item></channel></rss>