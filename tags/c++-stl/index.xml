<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ STL on Infinity Architect</title><link>https://cesun.info/tags/c++-stl/</link><description>Recent content in C++ STL on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 09 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/tags/c++-stl/index.xml" rel="self" type="application/rss+xml"/><item><title>STLv2</title><link>https://cesun.info/cxx/std/stlv2/</link><pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/stlv2/</guid><description>infrastructures Core concept ranges::range T satisfies range if ranges:begin(t) and ranges::end(t) compiles, where t is lvalue expression of type T.
e.g. Both vector&amp;lt;int&amp;gt; and vector&amp;lt;int&amp;gt;&amp;amp; satisfies range.
Core concept ranges::view Every view is range.
view captures a non-reference type T that satisfies range, plus its copy ctor (if exist), copy= (if exist), move ctor (must exist), move= (must exist) all work in O(1). e.g. std::string_view satisfies view, but std::string_view &amp;amp; does not.</description></item><item><title>Smart Pointers</title><link>https://cesun.info/cxx/std/smart-pointers/</link><pubDate>Sat, 27 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/smart-pointers/</guid><description>When not to use smart pointer Guideline:
raw pointer with new expression is always bad. there are situation in modern C++ where raw pointers make perfect sense. when destruction of resources is potentially-throwing Exception can&amp;rsquo;t be thrown from deleter. Use classic RAII class with noexcept(false) public API and noexcept(true) dtor instead of smart pointer.
https://stackoverflow.com/questions/130117/if-you-shouldnt-throw-exceptions-in-a-destructor-how-do-you-handle-errors-in-i
RAII class should be kept simple: never own 2 resources in 1 class.
Microsoft guide mentioned this (TODO: Bad things happends when RAII class wraps 2 resources?</description></item><item><title>C++ Randomness Infrastructure</title><link>https://cesun.info/cxx/std/random/</link><pubDate>Fri, 26 Apr 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/random/</guid><description>Support for randomness was introduced since C++11. Its design revolves around the following types of templates / classes / concepts:
Concept std::uniform_random_bit_generator Concept std::uniform_random_bit_generator models (class of) URBG (uniform random bit generators).
An URBG is a functor
whose operator() returns a sequence of uniformly random bits in the form of an unsigned integral value. (i.e. the returned integer is also uniform within min() and max()) whose class has min() and max() static member functions and they make sense.</description></item><item><title>Memo: Effective Modern C++ (Scott Meyers)</title><link>https://cesun.info/cxx/effective-modern-cxx/</link><pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/effective-modern-cxx/</guid><description>&lt;p>This is a memorandum on my walk through the Effective C++.
Most of these were written in Fall, 2020.&lt;/p></description></item><item><title>C++ STL Container &amp; Iterator</title><link>https://cesun.info/cxx/std/container/</link><pubDate>Thu, 23 Nov 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/std/container/</guid><description>C++ specification leaves the implementation of STL iterators to be vendor-defined.
1template&amp;lt;class T, class Allocator = allocator&amp;lt;T&amp;gt;&amp;gt; 2class vector { 3 using iterator = implementation-defined ; 4 using const_iterator = implementation-defined ; 5} copy vector over list https://stackoverflow.com/questions/2209224/vector-vs-list-in-stl#comment20988862_2209233 https://www.stroustrup.com/bs_faq.html#list
Bjarne Strostrup actually made a test where he generated random numbers and then added them to a list and a vector respectively. The insertions were made so that the list/vector was ordered at all times.</description></item><item><title>Memo: Effective C++ (Scott Meyers, 2006)</title><link>https://cesun.info/cxx/effective-cxx/</link><pubDate>Fri, 20 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/effective-cxx/</guid><description>&lt;p>This is a memorandum on my walk through the Effective C++.
Most of these were written in Fall, 2020.
Sections that don&amp;rsquo;t hold anymore for new C++11 and later are removed.&lt;/p></description></item><item><title>MEMO: C++ Core Guidelines (CCG)</title><link>https://cesun.info/cxx/ccg/</link><pubDate>Wed, 27 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/ccg/</guid><description>https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines
C.20: If you can avoid defining default operations, do. rule of zero:
Make a clear separation in mind between (1) resource-managing class, a.k.a (not precise, but) RAII class and (2) everything else (e.g. business related class) (1) should having no more public APIs other than the big 5, and optionally a raw resource getter. One seldom needs to write their own (1). STL containers and smart pointer with custom deleter should suffice.</description></item></channel></rss>