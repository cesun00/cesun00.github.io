<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Infinity Architect</title><link>https://cesun.info/tags/c/</link><description>Recent content in C on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 20 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/tags/c/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Randomness APIs</title><link>https://cesun.info/linux/random-api/</link><pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/random-api/</guid><description>C99 rand() and srand() Range: [0, RAND_MAX]
POSIX random() and srandom() Range: [0,2^31 - 1]
No standard specifies the distribution, though common implementations seems to be uniform. (don&amp;rsquo;t rely on that) credit.
POSIX rand48 family Uniform distribution random integer &amp;amp; float number generation.
&amp;ldquo;48&amp;rdquo; in those names indicates their nature of linear congruential algorithm with 48-bit modular arithmetic.
Such algorithms generate next random number sequence by recursively:
X_{n+1} = (a * X_n + c) % m copy The choice of (m, a, c) choice differs among implementations and papers.</description></item><item><title>The clang-format Formatter</title><link>https://cesun.info/cxx/clang/clang-format/</link><pubDate>Thu, 18 Jan 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/clang/clang-format/</guid><description>1clang-format [options] &amp;lt;source files ...&amp;gt; copy Supported coding style preset: LLVM, GNU, Google, Chromium, Microsoft, Mozilla, WebKit
ClangFormat respects a collection of format options, whose fallback values are specified by --fallback-style= options, which defaults to LLVM.
These format options are further overridden depending on the value of --style= CLI option, which defaults to file if omitted:
file: file .clang-format is searched in the containing directories of each given &amp;lt;source files&amp;gt;.</description></item><item><title>Spell That Declaration Correctly!</title><link>https://cesun.info/cxx/lang/cdecl/</link><pubDate>Fri, 22 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/lang/cdecl/</guid><description>Don&amp;rsquo;t mix pointers and non-pointers in the same declaration 1// do 2int *ptr_a, *ptr_b; 3int c; 4 5// don&amp;#39;t 6int* ptr_a, b; copy pointer to const vs. const pointer 1const int *ptr_a;	// pointer to const 2int *const ptr_b;	// const pointer; Recommended: asterisk preceeds const immediately copy a pointer to array vs. array of pointers 1int (*ptr_to_arr)[42]; // Pointer to an array 2int *ptr_arr[42]; // Array of pointers. copy 2d Array on Heap 1/** 2 * @brief 2D array malloc with compilation-time known size.</description></item><item><title>Compiler Builtins / Intrisics</title><link>https://cesun.info/cxx/compiler-builtins/</link><pubDate>Thu, 03 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/compiler-builtins/</guid><description>Most of these builtins translate to a single x86 instruction.
bit manipulations count leading (most significant) 0 1int __builtin_clz (unsigned int) 2int __builtin_clzl (unsigned long) 3int __builtin_clzll (unsigned long long) copy count trailing (least significant) 0 1int __builtin_ctz (unsigned int) 2int __builtin_ctzl (unsigned long) 3int __builtin_ctzll (unsigned long long) 4 5int __builtin_ffs (int x) 6int __builtin_ffsl (long) 7int __builtin_ffsll (long long) copy count occurrences of 1 1int __builtin_popcount (unsigned int x) 2int __builtin_popcountl (unsigned long) 3int __builtin_popcountll (unsigned long long) copy</description></item><item><title>Testing in C/C++</title><link>https://cesun.info/cxx/testing/</link><pubDate>Wed, 02 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/testing/</guid><description>&lt;p>JUnit and Mockito are the de-facto standard testing suites for Java; They are used by every company I know.
On the other side, there is hardly a standardized exercise for the C/C++ world on how software should be tested.&lt;/p>
&lt;p>This article is an overview of various testing methodologies for software / library written in C/C++.&lt;/p></description></item><item><title>GCC MISC</title><link>https://cesun.info/cxx/gcc/misc/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/cxx/gcc/misc/</guid><description>cc1 and cc1plus The output of gcc -v actually shows no invocation of the cpp preprocessor. Instead, cc1/cc1plus is invoked for both pre-processing and compilation of C/C++. My assumption is that those 2 programs fork-exec cpp.
GCC Developer Options -print-search-dirs
-print-sysroot
-print-prog-name
1gcc -print-prog-name=cc1 2/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/cc1 copy Specs String The gcc executable is a driver program, invoking other executables, e.g. cc1, as and collect2 (a wrapper around ld) to do the real job.</description></item><item><title>Fast Lexical Analyzer (Flex)</title><link>https://cesun.info/linux/flex/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/flex/</guid><description>The original lex program was written for the UNOS operating system in 1975. It was a proprietary software under the Bell Laboratories license. Nowadays open-source versions of lex based on the original proprietary code are available.
Flex is the free and open-source alternative to lex.
Vern Paxson took over the Software Tools lex project from Jef Poskanzer in 1982. At that point it was written in Ratfor. Around 1987 or so, Paxson translated it into C, and a legend was born :-).</description></item></channel></rss>