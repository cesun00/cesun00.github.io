<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GNU/Linux on Infinity Architect</title><link>https://cesun.info/linux/</link><description>Recent content in GNU/Linux on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 20 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Datetime API</title><link>https://cesun.info/linux/datetime-api/</link><pubDate>Tue, 26 Mar 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/datetime-api/</guid><description>&amp;ldquo;seconds/microseconds/etc. since the epoch&amp;rdquo; is approximate. See &amp;ldquo;NOTES&amp;rdquo; of man 2 time.
Types:
time_t (C99): second suseconds_t (POSIX): microseconds (10^-6 sec) struct timeval (POSIX): time_t (second) + suseconds_t (microseconds) struct timespec (C11 | POSIX): time_t (second) + long (nanosecond) struct tm (C89): for break-down time only, precision to second. The clock_*() family clockid_t: An integer type identifying a specific clock.
Each clock is said to have a precision. If a calendar time that is not a multiple of clock_settime().</description></item><item><title>Linux Randomness APIs</title><link>https://cesun.info/linux/random-api/</link><pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/random-api/</guid><description>C99 rand() and srand() Range: [0, RAND_MAX]
POSIX random() and srandom() Range: [0,2^31 - 1]
No standard specifies the distribution, though common implementations seems to be uniform. (don&amp;rsquo;t rely on that) credit.
POSIX rand48 family Uniform distribution random integer &amp;amp; float number generation.
&amp;ldquo;48&amp;rdquo; in those names indicates their nature of linear congruential algorithm with 48-bit modular arithmetic.
Such algorithms generate next random number sequence by recursively:
X_{n+1} = (a * X_n + c) % m copy The choice of (m, a, c) choice differs among implementations and papers.</description></item><item><title>A history of login password management: the shadow suite, glibc, and libxcrypt</title><link>https://cesun.info/linux/shadow-and-glibc/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/shadow-and-glibc/</guid><description>Linux was born in 1991. By the year of 1996, most Linux distros (including Slackware 2.3, Slackware 3.0, and other popular distributions) stored user information including passwords in the /etc/passwd file. This is a line-oriented text file where each line consists of colon-separated columns. The second column stores a crypto hash of the user password obtained from a char *crypt(const char *key, const char *salt); call.
This function dates back to the ages of Research UNIX.</description></item><item><title>Memo: diff(1) and patch(1) utilities</title><link>https://cesun.info/linux/diff-n-patch/</link><pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/diff-n-patch/</guid><description>The diff program is useful for comparing the difference of 2 files and generating a strictly formatted text report of the difference. Comparing 2 directories, defined by recursively comparing corresponding files with the same path, is supported. This is extremely useful for managing and releasing new versions of software in an incremental way before the widespread of source version control software like git. For example, early versions of glibc (1.01 to 1.</description></item><item><title>Boot Linux kernel without GRUB (or other bootloader)</title><link>https://cesun.info/linux/efistub/</link><pubDate>Thu, 14 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/efistub/</guid><description>The EFISTUB feature of the Linux kernel allows a kernel to be invoked directly as an EFI application, thus eliminate the necessity of using a bootloader.
First, check that your kernel has EFISTUB enabled:
1zgrep &amp;#39;CONFIG_EFI_STUB&amp;#39; /proc/config.gz copy 1efibootmgr --create 2 --disk ... # device node e.g. /dev/sdX 3 --part ... # partition number 4 --label ... # Entry Nickname 5 --loader &amp;#39;/vmlinuz-linux&amp;#39; # the executable path under the given partition 6 --unicode # interpret the following string in UCS-2 as argument to the EFI application, in our case, the kernel 7 &amp;#39;root=UUID=01a40dd8-28f0-4636-be1e-aeed60c98095 resume=UUID=2d877d5d-4ca1-4d46-a3d6-b6ee94cbbd78 rw rootflags=subvol=@ loglevel=3 quiet initrd=\initramfs-linux-lts.</description></item><item><title>Name Service Switch (NSS)</title><link>https://cesun.info/linux/nss/</link><pubDate>Mon, 11 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/nss/</guid><description>The Name Service Switch (NSS) is a convention in *NIX systems stating that the lookup order of certain administrative information should be configurable in a /etc/nsswitch.conf file.
The NSS workflow introduced in this article was first invented by the Ultrix developer in 1984 but the config file was /etc/svc.conf. Oracle Solaris was released in 1992 and was the first to call this pattern Name Service Switch.
GNU/Linux was actually late to the party.</description></item><item><title>Bash Shell Tricks &amp; Memos</title><link>https://cesun.info/linux/bash-misc/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/bash-misc/</guid><description>CLI Invocation -c:	The first non-option token after this option will be treated as a pipeline to be executed in the bash process. -s:	force bash to read from STDIN even positional argument is given, which would otherwise be interpret as the path to a script file. This allows positional parameters to be set when invoking an interactive shell. -i:	assume output is a tty device -l:	make the newly-invoked bash work as if it is a login shell -r:	invoke a restricted bash shell -v:	show more info on each command / step that bash executes; equivalent to --verbose The remaining tokens will be treated as the name of a bash script, and will be executed, if both</description></item><item><title>QEMU (Quick Emulator)</title><link>https://cesun.info/linux/qemu/</link><pubDate>Wed, 23 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/qemu/</guid><description>administrative qemu-img: qemu-keymap: qemu-storage-daemon: qemu-pr-helper: Persistent Reservation helper program for QEMU qemu-nbd: QEMU Disk Network Block Device Utility qemu-io: QEMU Disk exerciser qemu-edid: This is a test tool for the qemu edid generator. Linux CPU emulator (compiled for * emulation) qemu-aarch64 qemu-microblaze qemu-m68k qemu-riscv32 qemu-aarch64_be qemu-microblazeel qemu-riscv64 qemu-alpha qemu-mips qemu-s390x qemu-arm qemu-mips64 qemu-sh4 qemu-armeb qemu-mips64el qemu-sh4eb qemu-cris qemu-mipsel qemu-sparc qemu-mipsn32 qemu-sparc32plus qemu-hexagon qemu-mipsn32el qemu-sparc64 qemu-hppa qemu-i386 qemu-nios2 qemu-or1k qemu-x86_64 qemu-ppc qemu-xtensa qemu-ppc64 qemu-xtensaeb qemu-loongarch64 qemu-ppc64le qemu-system emulators qemu-system-m68k qemu-system-sh4 qemu-system-i386 qemu-system-rx qemu-system-loongarch64 qemu-system-s390x qemu-system-microblaze qemu-system-sh4eb qemu-system-microblazeel qemu-system-sparc qemu-system-mips qemu-system-sparc64 qemu-system-mips64 qemu-system-tricore qemu-system-mips64el qemu-system-x86_64 qemu-system-mipsel qemu-system-xtensa qemu-system-aarch64 qemu-system-nios2 qemu-system-xtensaeb qemu-system-alpha qemu-system-or1k qemu-system-arm qemu-system-ppc qemu-system-avr qemu-system-ppc64 qemu-system-cris qemu-system-riscv32 qemu-system-hppa qemu-system-riscv64 man pages # ls qemu* -hl -rw-r--r-- 1 root root 62K Mar 28 04:34 qemu.</description></item><item><title>Memo: pthread</title><link>https://cesun.info/linux/pthread/</link><pubDate>Mon, 21 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/pthread/</guid><description>Thread Termination vs. Process Exit A thread terminates in one of the following ways:
It calls pthread_exit(3), specifying an exit status value that is available to another thread in the same process that calls pthread_join(3).
It returns from start_routine(). This is equivalent to calling pthread_exit(3) with the value supplied in the return statement.
It is canceled (see pthread_cancel(3)).
Any of the threads in the process calls exit(3), or the main thread performs a return from main().</description></item><item><title>Retrospection: The Linux Libc</title><link>https://cesun.info/linux/linux-libc/</link><pubDate>Sat, 12 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/linux-libc/</guid><description>https://web.archive.org/web/20040411191201/http://people.redhat.com/~sopwith/old/glibc-vs-libc5.html https://www.maketecheasier.com/history-of-early-linux-distros/ https://lwn.net/Articles/417647/ POSIX.1 was defined by the IEEE Std 1003.1-1988 specification released in 1988. The Linux kernel was written in 1991. The GNU project was already famous at that time: GCC was first released in March 1987, and
The kernel team needed a userspace C runtime as wrapper for system calls as well as providing various non-kernel utilities. GNU&amp;rsquo;s glibc 0.1 was released already.
Many claim that the Linux libc was a fork of from glibc v1.</description></item><item><title>Virtual File Systems</title><link>https://cesun.info/linux/vfs/</link><pubDate>Wed, 26 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/vfs/</guid><description>Historically, if a privileged program want to consult content of certain kernel data structure, the only way is to read and interpret /dev/kmem directly, which is obviously dangerous and error prone.
The now recommended approach is to read entries in the proc VFS conventionally mounted at /proc. In deprecation of the legacy method, ince Linux 2.6.26, /dev/kmem file is available only if the kernel is compiled with CONFIG_DEVKMEM.
https://www.kernel.org/doc/html/latest/filesystems/vfs.html
procfs Linux expose certain task-related kernel structures via write and read syscalls, instead of having a new syscalls.</description></item><item><title>Linux keyboard input</title><link>https://cesun.info/linux/key-input/</link><pubDate>Thu, 13 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/key-input/</guid><description>This article explain how keyboard events are emits from hardware and delivered to userspace applications.
Overview Keyboard hareware sends scancode to kernel. Kernel translates scancode to keycode. keyboard layout defines the mapping from (keycode, modifiers...) tuple to keysym, which is either a printable character, or an action to carry out (e.g. volumn up /down/reboot). character set (or charset) assigns each keysym symbol a specific number. key composition: in some language, typing 2 keys on the keyboard should produce a single accented letter.</description></item><item><title>Systemd Overview</title><link>https://cesun.info/linux/systemd/</link><pubDate>Tue, 11 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/systemd/</guid><description>Overview unit: vertex in the dependency graph job: a request for state change to a unit; each unit has a job queue. 11 types of units:
unit type man page Notable instance Service systemd.service(5) - which start and control daemons and the processes they consist of. privoxy.service Socket systemd.socket(5) Start another .service unit when certain socket has incoming traffic, i.e. inetd replacement dbus.socket - which encapsulate local IPC or network sockets in the system, useful for socket-based activation.</description></item><item><title>Fast Lexical Analyzer (Flex)</title><link>https://cesun.info/linux/flex/</link><pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/flex/</guid><description>The original lex program was written for the UNOS operating system in 1975. It was a proprietary software under the Bell Laboratories license. Nowadays open-source versions of lex based on the original proprietary code are available.
Flex is the free and open-source alternative to lex.
Vern Paxson took over the Software Tools lex project from Jef Poskanzer in 1982. At that point it was written in Ratfor. Around 1987 or so, Paxson translated it into C, and a legend was born :-).</description></item></channel></rss>