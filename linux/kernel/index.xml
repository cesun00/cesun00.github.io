<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Linux Kernel on Infinity Architect</title><link>https://cesun.info/linux/kernel/</link><description>Recent content in The Linux Kernel on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 25 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/linux/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU Frequency Control</title><link>https://cesun.info/linux/kernel/cpufreq/</link><pubDate>Fri, 23 Feb 2024 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/cpufreq/</guid><description>https://www.kernel.org/doc/html/v5.8/admin-guide/pm/cpufreq.html
The &amp;ldquo;cpufreq&amp;rdquo; subsystem manages the cpu frequency scaling.
It consists of three layers of code:
the core - a general framework for governors and drivers to be implemented. scaling governors - algorithms that estimate required CPU capacity and send request to driver to adjust p-state. &amp;ldquo;As a rule, each governor implements one, possibly parametrized, scaling algorithm&amp;rdquo;
scaling drivers - talk to hardware; provide a unified API to governor algorithm IMPORTANT: only one driver can registered at a time, and it&amp;rsquo;s expected to handle all CPUs available.</description></item><item><title>Linux Control Group V2 (cgroup2)</title><link>https://cesun.info/linux/kernel/cgroupv2/</link><pubDate>Fri, 01 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/cgroupv2/</guid><description>&lt;p>This article gives an introduction to cgroup.&lt;/p>
&lt;p>The Control Group (cgroup) is a feature of the Linux kernel that allows organizing arbitrary processes into groups such that restrictions on resources can be imposed in terms of that group by an administrator, and statistics are collected in terms of that group. Windows Desktop currently doesn&amp;rsquo;t have such a feature.&lt;/p></description></item><item><title>On the Build System of Linux Kernel</title><link>https://cesun.info/linux/kernel/build/</link><pubDate>Wed, 06 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/build/</guid><description>&lt;p>This article analyzes the building process of the Linux kernel, including the implementation of &lt;code>Makefile&lt;/code>s. Various build-time generated files and build techniques are discussed.&lt;/p>
&lt;p>It is well-known that the Linux kernel should be built by &lt;code>make *config&lt;/code> followed by a &lt;code>make&lt;/code> call without a goal.
The &lt;code>make *config&lt;/code> command does nothing more than invoke a wizard program, which may include compiling that wizard program first.
It&amp;rsquo;s the wizard program&amp;rsquo;s responsibility to properly generate a &lt;code>.config&lt;/code> file which holds the user&amp;rsquo;s choice on the kernel building configs.&lt;/p></description></item><item><title>Linux eBPF Subsystem</title><link>https://cesun.info/linux/kernel/ebpf/</link><pubDate>Mon, 04 Sep 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/ebpf/</guid><description>The DIGITAL UNIX Packet Filter The Digital Equipment Corporation (DEC), founded in 1957 and defuncted in 1998, once owned 2 Unix variants, Ultrix (based on BSD) and Tru64 Unix (based on OSF/1). Tru64 Unix is also known as the &amp;ldquo;Digital Unix&amp;rdquo; (digital from DEC&amp;rsquo;s name). Tru64 was then purchased by Compaq and finally the HP company.
Tru64 Unix provided a network packet filtering mechanics known as The DIGITAL UNIX Packet Filter, aka.</description></item><item><title>The Linux Syscalls</title><link>https://cesun.info/linux/kernel/syscalls/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/syscalls/</guid><description>glibc dynamic syscall wrapper:
1#include &amp;lt;unistd.h&amp;gt; 2 3long syscall(long number, ...); copy Mnemonic macros for number are defined in &amp;lt;sys/syscall.h&amp;gt;:
1#include &amp;lt;sys/syscall.h&amp;gt; 2long syscall(SYS_clone3, struct clone_args *cl_args, size_t size); copy API layer The system calls entrance point API layer of the linux kernel.
1// include/linux/syscalls.h 2 3#ifndef SYSCALL_DEFINE0 4#define SYSCALL_DEFINE0(sname)	\ 5	SYSCALL_METADATA(_##sname, 0);	\ 6	asmlinkage long sys_##sname(void);	\ 7	ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);	\ 8	asmlinkage long sys_##sname(void) 9#endif /* SYSCALL_DEFINE0 */ 10 11#define SYSCALL_DEFINE1(name, .</description></item><item><title>Files</title><link>https://cesun.info/linux/kernel/file/</link><pubDate>Mon, 07 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/linux/kernel/file/</guid><description>File descriptor &amp;amp; File Description A file description is an instance of struct file (in &amp;lt;linux/fs.h&amp;gt;). Every call to open(2) creates a new instance, and put it into a system-wide open file table. File descriptions are system-wide, and solely managed by the kernel.
https://github.com/torvalds/linux/blob/master/include/linux/fs.h
1struct file { 2	union { 3	struct llist_node	fu_llist; 4	struct rcu_head fu_rcuhead; 5	} f_u; 6	struct path	f_path; 7	struct inode	*f_inode;	/* cached value */ 8	const struct file_operations	*f_op; 9 10	/* 11	* Protects f_ep, f_flags.</description></item></channel></rss>