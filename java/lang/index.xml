<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>The Java Language on Infinity Architect</title><link>https://cesun.info/java/lang/</link><description>Recent content in The Java Language on Infinity Architect</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://cesun.info/java/lang/index.xml" rel="self" type="application/rss+xml"/><item><title>Enum Implements Interfaces</title><link>https://cesun.info/java/lang/fancy-enum/</link><pubDate>Tue, 12 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/java/lang/fancy-enum/</guid><description>&lt;p>&lt;code>enum&lt;/code> in Java is a syntax sugar of &lt;code>class ... extends Enum&amp;lt;&amp;gt;&lt;/code>.
It shouldn&amp;rsquo;t be surprising that it can thus implement interfaces.
This article discusses some less-known consequences of that.&lt;/p></description></item><item><title>Introduction to Java 9 Module</title><link>https://cesun.info/java/lang/java9-module/</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/java/lang/java9-module/</guid><description>&lt;p>Java 9 introduced a modularization system and used it to modularize the JDK itself.
This article aims to provide all the information necessary for a Java developer to work with the module system.&lt;/p>
&lt;p>We will first pretend Java 9 is a new language where modules are the only development paradigm.
After a quick demonstration of the module workflow, we&amp;rsquo;ll discuss how module works in detail, and introducing the mechanics underneath.
Finally, we&amp;rsquo;ll take a step back to the reality and discuss how non-module legacy Java 8 codes are handled by the Java 9 toolchains.&lt;/p></description></item><item><title>Java Service Provider Interface (SPI)</title><link>https://cesun.info/java/lang/spi/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/java/lang/spi/</guid><description>&lt;p>This article introduces the Java Service Provider Interface (SPI).
SPI workflow in Java 8 and before is first discussed, followed by the improvement brought by Java 9.&lt;/p></description></item><item><title>Java Language Feature: Annotation</title><link>https://cesun.info/java/lang/annotation/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/java/lang/annotation/</guid><description>The annotation construct that facilitates all sorts of magic in Java.
1@Retention(RetentionPolicy.RUNTIME) 2@Target({ElementType.TYPE_USE, ElementType.METHOD}) 3public @interface Foo { 4} 5 6@Foo 7Integer getMenaing() { 8return 42; 9} copy java.lang.Integer getMenaing(); descriptor: ()Ljava/lang/Integer; flags: (0x0000) Code: stack=1, locals=1, args_size=1 0: bipush 42 2: invokestatic #7 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: areturn LineNumberTable: line 7: 0 LocalVariableTable: Start Length Slot Name Signature 0 6 0 this Lcc/Main; RuntimeVisibleAnnotations: 0: #23() cc.FG RuntimeVisibleTypeAnnotations: 0: #23(): METHOD_RETURN cc.</description></item><item><title>Java Generic Typing</title><link>https://cesun.info/java/lang/generics/</link><pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate><guid>https://cesun.info/java/lang/generics/</guid><description>Java generics enable types (classes and interfaces) to be parameters when defining:
classes, interfaces, and methods. Essentially, generics is a mechanism to ensure type-safety at compile time, so that programmers do not need to write downcast manually. javac compiler now generate surefire downcast, after checking types are compatible, or complain if not.
Syntaxes for declaring type parameters:
interface/class: type parameters between class/interface name and superclass/superinterfaces method: type parameters between modifiers and return type 1interface I&amp;lt;T0,T1,.</description></item></channel></rss>